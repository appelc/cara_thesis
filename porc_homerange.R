# ---------------------------------------------------------------
## Home range calculation using KDE and MCP
## Includes overlap metrics, t-tests, body mass vs. HR size linear regression, and summary stats
# ---------------------------------------------------------------

library(adehabitatHR)
library(googlesheets)
library(raster)
library(rgeos)
library(reshape2)

# ---------------------------------------------------------------
## 1. First, load porcupine location data
## (SKIP TO LINE 41 IF USING A CSV OR NOT INCORPORATING NEW VHF DATA)
# ---------------------------------------------------------------
gs_ls()
locs <- gs_title("Porc relocation data")
porc.vhf <- data.frame(gs_read(ss=locs, ws="Relocations", is.na(TRUE), range=cell_cols(c(1:8))))
colnames(porc.vhf) <- c("date", "id", "sess", "type", "time", "az", "utm_e", "utm_n")
porc.vhf <- subset(porc.vhf, type %in% c("V","V*","P","P*","L"))
porc.vhf$utm_e <- as.numeric(porc.vhf$utm_e)
porc.vhf$utm_n <- as.numeric(porc.vhf$utm_n)
porc.vhf$date <- as.Date(porc.vhf$date, "%m/%d/%Y") #or: porc.vhf$date <- as.Date(porc.vhf$date, origin = as.Date("1899-12-30"))

## Incorporate GPS data (1 random point per day)
porc.gps <- read.csv('csvs/daily_gps_090416.csv') ## generated by 'gps_clean_IA.R'
porc.gps$type <- rep("gps", nrow(porc.gps))
porc.gps$az <- rep(NA, nrow(porc.gps))
porc.gps$Animal.ID <- as.character(porc.gps$Animal.ID)
porc.gps$Animal.ID[porc.gps$Animal.ID == '16.2'] <- '16.20' ## why do I have to do this?
porc.gps.df <- data.frame(porc.gps$Date, porc.gps$Animal.ID, porc.gps$Session, porc.gps$type,
                          porc.gps$Time, porc.gps$az, porc.gps$UTM.E, porc.gps$UTM.N)
colnames(porc.gps.df) <- colnames(porc.vhf)
porc.gps.df$date <- as.Date(porc.gps.df$date, "%Y-%m-%d")
porc.gps.df$id <- as.factor(porc.gps.df$id)

## combine VHF with GPS points
porc.locs <- rbind(porc.vhf, porc.gps.df)
#porc.locs <- porc.vhf #RUN THIS IF NOT USING GPS POINTS

## SKIP TO HERE UNLESS INCORPORATING NEW POINTS (this CSV has the exact points I used for my thesis analysis - CA)
porc.locs <- read.csv('csvs/porc_locs_thesis_final.csv')
porc.locs$date <- as.Date(porc.locs$date)

porc.locs$id <- as.character(porc.locs$id)
  porc.locs$id[porc.locs$id == '15.1'] <- '15.10' 
  porc.locs$id[porc.locs$id == '16.2'] <- '16.20' 
  porc.locs$id <- as.factor(porc.locs$id) 

## subset summer locations (before Nov 1 or after March 1) and winter (between Nov 1 and March 1)
## (WILL NEED TO MODIFY THIS FOR DATA PAST SUMMER 2016)
sum15.cutoff <- '2015-11-01' 
win16.cutoff <- '2016-03-01'
  sum.locs <- porc.locs[(porc.locs$date < sum15.cutoff) | (porc.locs$date >= win16.cutoff), ]
  win.locs <- porc.locs[(porc.locs$date >= sum15.cutoff) & (porc.locs$date < win16.cutoff), ]

## Keep only animals with >= 5 locations in each season (and overall; this only applies to 16.16)
n <- table(sum.locs$id)
  sum.locs <- subset(sum.locs, id %in% names(n[n >= 5]), drop=TRUE)
  sum.locs <- droplevels(sum.locs)

n <- table(win.locs$id)
  win.locs <- subset(win.locs, id %in% names(n[n >= 5]), drop=TRUE)
  win.locs <- droplevels(win.locs)

n <- table(porc.locs$id)
  porc.locs <- subset(porc.locs, id %in% names(n[n >= 5]), drop=TRUE)
  porc.locs <- droplevels(porc.locs)

# ---------------------------------------------------------------
## 2. Then, extract the UD from "adehabitatHR" package
# ---------------------------------------------------------------

## Calculate grid & extent based on desired cell size (# meters on each side) 
##  for each animal separately 

  ## for clipping to study area (optional 2nd half of this loop for habitat seletion):  
  library(rgdal)
  veg.ext <- readOGR(dsn="shapefiles", layer="Veg extent4", verbose=TRUE)
  proj4string(veg.ext) <- CRS("+proj=utm +zone=10 +datum=NAD83")
  ##

ids <- unique(porc.locs$id)
kde.areas <- list()
kud.all <- list()
overlap <- list()
overlap.core <- list()
contours.95 <- list()
contours.50 <- list()
outer_cont95 <- list()
contours95 <- list()
ud.list <- list()

for (i in ids){
        locs.i <- porc.locs[porc.locs$id == i,]
        locs.i$id_season <- rep(paste(i, "_all", sep = ""), nrow(locs.i))
        locs.sum.i <- sum.locs[sum.locs$id == i,]
        locs.sum.i$id_season <- rep(paste(i, "_sum", sep = ""), nrow(locs.sum.i))
        locs.win.i <- win.locs[win.locs$id == i,]
        locs.win.i$id_season <- rep(paste(i, "_win", sep = ""), nrow(locs.win.i))
        locs.all.i <- rbind(locs.i, locs.sum.i, locs.win.i)
        sp.i <- SpatialPointsDataFrame(data.frame(locs.all.i$utm_e, locs.all.i$utm_n),
                                       data=data.frame(locs.all.i$id_season),
                                       proj4string=CRS("+proj=utm +zone=10 +datum=NAD83"))
     c = 10   ## desired cell size (meters)
        fake.kern <- kernelUD(xy = sp.i, extent = 1)
        spdf <- raster(as(fake.kern[[1]], "SpatialPixelsDataFrame"))
        eas <- diff(range(spdf@extent[1:2]))
        nor <- diff(range(spdf@extent[3:4]))
        if(eas > nor){
          g <- (eas/c)
        } else {
          g <- (nor/c)
        }
        
      # calculate UD on all IDs ("all", "winter", and "summer") with same4all = TRUE
        kern.i <- kernelUD(xy = sp.i, h = 60, grid = g, extent = 1, same4all = TRUE)
        kde.i <- kernel.area(kern.i, percent = c(50, 90, 95, 99), unin = "m", unout = "km2", standardize = FALSE)
        data.frame(kde.i, row.names = c("50", "90", "95", "99"))
        kde.areas[[i]] <- kde.i
        kud.all[[i]] <- kern.i
        
      # calculate overlap using UDOI method ('UD overlap index' from Fieberg and Kochanny 2010)
        if (length(kern.i) > 2){
          overlap.i <- kerneloverlaphr(kern.i, method = 'UDOI', percent = 95, conditional = TRUE)
          overlap.i.50 <- kerneloverlaphr(kern.i, method = 'UDOI', percent = 50, conditional = TRUE)
          overlap[[i]] <- overlap.i # store comparisons between overall/summer/winter for each animal
          overlap.core[[i]] <- overlap.i.50
        }
        
      # make 95% contours
        cont95 <- list()
        for (j in names(kern.i)){
            cont95.i <- getverticeshr.estUD(kern.i[[j]], percent = 95, unin = "m", unout = "km2", standardize = FALSE)
            cont95[[j]] <- cont95.i
        }
        contours.95[[i]] <- cont95
        
      # make 50% contours
        cont50 <- list()
        for (j in names(kern.i)){
          cont50.i <- getverticeshr.estUD(kern.i[[j]], percent = 50, unin = "m", unout = "km2", standardize = FALSE)
          cont50[[j]] <- cont50.i
        }
        contours.50[[i]] <- cont50
        
  ## THE REST OF THIS LOOP IS ONLY NEEDED FOR HABITAT SELECTION ANALYSIS,
  ## BUT I INCLUDED IT HERE TO MAKE SEASONAL UD FIGURES (SEE STEP #13)
        
       ## merge all 3 contours to make a single contour based on the outermost boundary
        outer_cont95.i <- raster::union(cont95[[1]], cont95[[2]])
        if ((length(cont95)) > 2) {
          outer_cont95.i <- raster::union(outer_cont95.i, cont95[[3]]) ## because not all have winter
        }
        
        outer_cont95.i <- gUnaryUnion(outer_cont95.i) ## dissolve polygons but this gets rid of @data
        outer_cont95.i <- gIntersection(outer_cont95.i, veg.ext, byid = F) ## because some contours go outside study area
        outer_cont95.i@polygons[[1]]@ID <- 'homerange' ## so it will match when creating SPDF below
        
       ## create @data to make it a SPDF (necessary for later steps)
        row_data <- data.frame('homerange', (outer_cont95.i@polygons[[1]]@Polygons[[1]]@area))
        rownames(row_data) <- rep('homerange', nrow(row_data))
        colnames(row_data) <- c('id', 'area')
        outer_cont95.i <- SpatialPolygonsDataFrame(outer_cont95.i, data = row_data)
        
       ## store contours (access as follows: contours[[i]][[j]] where i = ID and j = 1:all, 2:sum, 3:win)
        outer_cont95[[i]] <- outer_cont95.i ## store outer contours
        contours95[[i]] <- cont95 ## store all contours
        
       ## clip summer & winter UD grids to the 95% outer contour and veg extent
        ud.i <- list()
        for (j in names(kern.i)){
          clipped.ud.i <- (kern.i[[j]])[outer_cont95.i,] ## outer boundary from ALL contours, see above
          clipped.ud.i <- clipped.ud.i[veg.ext,]
          ud.i[[j]] <- clipped.ud.i
        }
        ud.list[[i]] <- ud.i
        
}

# ---------------------------------------------------------------
## 3. Organize list of KDE areas
# ---------------------------------------------------------------

ids <- names(kde.areas)
kde.all <- NULL
for(i in ids){
    kdes.i <- NULL
  for (j in names(kde.areas[[i]])){
        kde <- (kde.areas[[i]])[j]
        kde$season <- rep(substr(j, start = 8, stop = 10), nrow(kde))
        kde$method <- rep('kde', nrow(kde))
        colnames(kde) <- c('km2', 'season', 'method')
        per <- c('50', '90', '95', '99')
        kde.df <- data.frame(i, per, kde$km2, kde$season, kde$method)
        colnames(kde.df) <- c('id', 'percent', 'area', 'season', 'method')
        kdes.i <- rbind(kdes.i, kde.df)
        }
      kde.all <- rbind(kde.all, kdes.i)    
}


# ---------------------------------------------------------------
## 4. Quick plot of home ranges (optional) & export shapefiles
# ---------------------------------------------------------------

plot(veg.ext)
for (i in f){
  plot(contours.95[[i]][[2]], add = TRUE, lty = 1, lwd = 2)
}

for (i in names(contours.95)){ 
  contours.95.i <- contours.95[[i]]  
    for (j in names(contours.95.i)){ 
      myname <- paste(j, '95kde', sep = '_')
      writeOGR(contours.95.i[[j]], dsn = 'Shapefiles/95_kde/home_ranges_101616', layer = myname, driver="ESRI Shapefile")
    }
}

for (i in names(contours.50)){ 
  contours.50.i <- contours.50[[i]]  
  for (j in names(contours.50.i)){ 
    myname <- paste(j, '50kde', sep = '_')
    writeOGR(contours.50.i[[j]], dsn = 'Shapefiles/50_kde/home_ranges_101616', layer = myname, driver="ESRI Shapefile")
  }
}

# ---------------------------------------------------------------
## 5. Calculate MCPs
# ---------------------------------------------------------------

## all points 95%
all.df <- data.frame(porc.locs$utm_e, porc.locs$utm_n, porc.locs$id, porc.locs$date)
colnames(all.df) <- c("x", "y", "id", "date")
all.spdf <- SpatialPointsDataFrame(data.frame(all.df$x, all.df$y),
                                   data=data.frame(all.df$id),
                                   proj4string=CRS("+proj=utm +zone=10 +datum=NAD83"))

mcp.all95 <- mcp(all.spdf, percent = 95, unin="m", unout="km2")
plot(mcp.all95, main="95% MCP, All")
mcp.all95.df <- data.frame(mcp.all95$id, rep('95', nrow(mcp.all95)), mcp.all95$area,
                           rep('all', nrow(mcp.all95)), rep('mcp', nrow(mcp.all95)))
colnames(mcp.all95.df) <- c('id', 'percent', 'area', 'season', 'method')
write.csv(mcp.all95.df, "csvs/mcp_all_95_091016.csv")

## summer 95%
sum.df <- data.frame(sum.locs$utm_e, sum.locs$utm_n, sum.locs$id, sum.locs$date)
colnames(sum.df) <- c("x", "y", "id", "date")
sum.spdf <- SpatialPointsDataFrame(data.frame(sum.df$x, sum.df$y),
                                   data = data.frame(sum.df$id),
                                   proj4string = CRS("+proj=utm +zone=10 +datum=NAD83"))
mcp.sum95 <- mcp(sum.spdf, percent = 95, unin = 'm', unout = 'km2')
plot(mcp.sum95, main = '95% MCP, Summer')
mcp.sum95.df <- data.frame(mcp.sum95$id, rep('95', nrow(mcp.sum95)), mcp.sum95$area,
                           rep('sum', nrow(mcp.sum95)), rep('mcp', nrow(mcp.sum95)))
colnames(mcp.sum95.df) <- c('id', 'percent', 'area', 'season', 'method')
write.csv(mcp.sum95.df, "csvs/mcp_sum_95_091016.csv")

## winter 95%
win.df <- data.frame(win.locs$utm_e, win.locs$utm_n, win.locs$id, win.locs$date)
colnames(win.df) <- c("x", "y", "id", "date")
win.spdf <- SpatialPointsDataFrame(data.frame(win.df$x, win.df$y),
                                   data = data.frame(win.df$id),
                                   proj4string = CRS("+proj=utm +zone=10 +datum=NAD83"))
mcp.win95 <- mcp(win.spdf, percent = 95, unin = 'm', unout = 'km2')
plot(mcp.win95, main = '95% MCP, Winter')
mcp.win95.df <- data.frame(mcp.win95$id, rep('95', nrow(mcp.win95)), mcp.win95$area,
                           rep('win', nrow(mcp.win95)), rep('mcp', nrow(mcp.win95)))
colnames(mcp.win95.df) <- c('id', 'percent', 'area', 'season', 'method')
write.csv(mcp.win95.df, "csvs/mcp_win_95_091016.csv")

mcp.all <- rbind(mcp.all95.df, mcp.sum95.df, mcp.win95.df)

writeOGR(mcp.sum95, dsn = 'Shapefiles/home_ranges_101616/mcp', layer = 'summer_95_mcp', driver = 'ESRI Shapefile')
writeOGR(mcp.win95, dsn = 'Shapefiles/home_ranges_101616/mcp', layer = 'winter_95_mcp', driver = 'ESRI Shapefile')

## 50% MCPs are for plotting only (not used in any analysis -- can skip this)
## summer 50%
sum.df <- data.frame(sum.locs$utm_e, sum.locs$utm_n, sum.locs$id, sum.locs$date)
colnames(sum.df) <- c("x", "y", "id", "date")
sum.spdf <- SpatialPointsDataFrame(data.frame(sum.df$x, sum.df$y),
                                   data = data.frame(sum.df$id),
                                   proj4string = CRS("+proj=utm +zone=10 +datum=NAD83"))
mcp.sum50 <- mcp(sum.spdf, percent = 50, unin = 'm', unout = 'km2')
plot(mcp.sum50, main = '50% MCP, Summer')
mcp.sum50.df <- data.frame(mcp.sum50$id, rep('50', nrow(mcp.sum50)), mcp.sum50$area,
                           rep('sum', nrow(mcp.sum50)), rep('mcp', nrow(mcp.sum50)))
colnames(mcp.sum50.df) <- c('id', 'percent', 'area', 'season', 'method')
write.csv(mcp.sum50.df, "csvs/mcp_sum_50_101616.csv")

## winter 50%
win.df <- data.frame(win.locs$utm_e, win.locs$utm_n, win.locs$id, win.locs$date)
colnames(win.df) <- c("x", "y", "id", "date")
win.spdf <- SpatialPointsDataFrame(data.frame(win.df$x, win.df$y),
                                   data = data.frame(win.df$id),
                                   proj4string = CRS("+proj=utm +zone=10 +datum=NAD83"))
mcp.win50 <- mcp(win.spdf, percent = 50, unin = 'm', unout = 'km2')
plot(mcp.win50, main = '50% MCP, Winter')
mcp.win50.df <- data.frame(mcp.win50$id, rep('50', nrow(mcp.win50)), mcp.win50$area,
                           rep('win', nrow(mcp.win50)), rep('mcp', nrow(mcp.win50)))
colnames(mcp.win50.df) <- c('id', 'percent', 'area', 'season', 'method')
write.csv(mcp.win50.df, "csvs/mcp_win_50_101616.csv")

writeOGR(mcp.sum50, dsn = 'Shapefiles/home_ranges_101616/mcp', layer = 'summer_50_mcp', driver = 'ESRI Shapefile')
writeOGR(mcp.win50, dsn = 'Shapefiles/home_ranges_101616/mcp', layer = 'winter_50_mcp', driver = 'ESRI Shapefile')

# ---------------------------------------------------------------
## 6. Now do summary statistics (means, etc.)
# ---------------------------------------------------------------

hr.all <- rbind(kde.all, mcp.all) # combine MCP and KDE

## NEED TO ADD SEX FOR ANIMALS AFTER 16.20
hr.all$sex[hr.all$id %in% c('15.01', '15.02', '15.05', '15.07', '15.08', '15.09', '15.10', '15.12', '15.13', '16.16', '16.17')] <- 'f'
hr.all$sex[hr.all$id %in% c('15.03', '15.04', '15.06', '15.11', '15.14', '16.15', '16.18', '16.19', '16.20')] <- 'm'

## remove 15.04 (home range may represent dispersal...)
hr.all <- hr.all[hr.all$id != '15.04',]

## aggregate and compute SE
hr.summary <- aggregate(hr.all$area, by = list(sex = hr.all$sex, season = hr.all$season, method = hr.all$method, percent = hr.all$percent),
                        FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
hr.summary <- do.call(data.frame, hr.summary) # make data frames instead of matrices
  colnames(hr.summary) <- c('sex', 'season', 'method', 'percent', 'mean', 'sd', 'n')
  hr.summary$se <- hr.summary$sd / sqrt(hr.summary$n)
  hr.summary$names <- c(paste(hr.summary$sex, hr.summary$season, sep = '_'))

## change file name and directory to export summary:
write.csv(hr.summary, 'csvs/homeranges091016.csv')

## mean and SE of both males/females (b/c not computed automatically in aggregate)
all.sum.50kde <- hr.all[hr.all$percent == 50 & hr.all$method == 'kde' & hr.all$season == 'sum',]$area
  mean(all.sum.50kde)
  (n <- length(all.sum.50kde))
  sd(all.sum.50kde) / n
all.win.50kde <- hr.all[hr.all$percent == 50 & hr.all$method == 'kde' & hr.all$season == 'win',]$area
  mean(all.win.50kde)
  (n <- length(all.win.50kde))
  sd(all.win.50kde) / n
all.sum.90kde <- hr.all[hr.all$percent == 90 & hr.all$method == 'kde' & hr.all$season == 'sum',]$area
  mean(all.sum.90kde)
  (n <- length(all.sum.90kde))
  sd(all.sum.90kde) / n
all.win.90kde <- hr.all[hr.all$percent == 90 & hr.all$method == 'kde' & hr.all$season == 'win',]$area
  mean(all.win.90kde)
  (n <- length(all.win.90kde))
  sd(all.win.90kde) / n
all.sum.95kde <- hr.all[hr.all$percent == 95 & hr.all$method == 'kde' & hr.all$season == 'sum',]$area
  mean(all.sum.95kde)
  (n <- length(all.sum.95kde))
  sd(all.sum.95kde) / n
all.win.95kde <- hr.all[hr.all$percent == 95 & hr.all$method == 'kde' & hr.all$season == 'win',]$area
  mean(all.win.95kde)
  (n <- length(all.win.95kde))
  sd(all.win.95kde) / n
all.sum.95mcp <- hr.all[hr.all$percent == 95 & hr.all$method == 'mcp' & hr.all$season == 'sum',]$area
  mean(all.sum.95mcp)
  (n <- length(all.sum.95mcp))
  sd(all.sum.95mcp) / n
all.win.95mcp <- hr.all[hr.all$percent == 95 & hr.all$method == 'mcp' & hr.all$season == 'win',]$area
  mean(all.win.95mcp)
  (n <- length(all.win.95mcp))
  sd(all.win.95mcp) / n
  
## both seasons, both sexes (these aren't in the aggregate)
all.all.50kde <- hr.all[hr.all$percent == 50 & hr.all$method == 'kde' & hr.all$season == 'all',]$area
  mean(all.all.50kde)
  (n <- length(all.all.50kde))
  sd(all.all.50kde) / n 
all.all.90kde <- hr.all[hr.all$percent == 90 & hr.all$method == 'kde' & hr.all$season == 'all',]$area
  mean(all.all.90kde)
  (n <- length(all.all.90kde))
  sd(all.all.90kde) / n 
all.all.95kde <- hr.all[hr.all$percent == 95 & hr.all$method == 'kde' & hr.all$season == 'all',]$area
  mean(all.all.95kde)
  (n <- length(all.all.95kde))
  sd(all.all.95kde) / n
all.all.95mcp <- hr.all[hr.all$percent == 95 & hr.all$method == 'mcp' & hr.all$season == 'all',]$area
  mean(all.all.95mcp)
  (n <- length(all.all.95mcp))
  sd(all.all.95mcp) / n 

## CAN SKIP THIS NEXT PART:
## now do this all over again using ONLY animals with both summer and winter home ranges
## b/c these are the ones used in paired t-tests below
## (Just out of curiousity. I report the above values for all porcupines in results.)

hr.all.mod <- subset(hr.all, id %in% c('15.01', '15.02', '15.03', '15.07', '15.11', '15.12', '15.13', '15.14', '16.15', '16.17', '16.18'), drop = TRUE)
hr.all.mod$id <- droplevels(hr.all.mod$id)
hr.mod.summary <- aggregate(hr.all.mod$area, by = list(sex = hr.all.mod$sex, season = hr.all.mod$season, method = hr.all.mod$method, percent = hr.all.mod$percent),
                        FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
hr.mod.summary <- do.call(data.frame, hr.mod.summary) # make data frames instead of matrices
colnames(hr.mod.summary) <- c('sex', 'season', 'method', 'percent', 'mean', 'sd', 'n')
hr.mod.summary$se <- hr.mod.summary$sd / sqrt(hr.mod.summary$n)
hr.mod.summary$names <- c(paste(hr.mod.summary$sex, hr.mod.summary$season, sep = '_'))
write.csv(hr.mod.summary, 'csvs/homeranges_mod091016.csv')

# ---------------------------------------------------------------
## 7. Now make bar graphs
# ---------------------------------------------------------------

## first, subset only 95% KDEs
hr.summary.kde <- hr.summary[hr.summary$method == 'kde' & hr.summary$percent == '95',]
  hr.summary.kde$sex <- as.character(hr.summary.kde$sex)
  hr.summary.kde$sex[hr.summary.kde$sex == 'm'] <- 'males'
  hr.summary.kde$sex[hr.summary.kde$sex == 'f'] <- 'females'

hr.mod.summary.kde <- hr.mod.summary[hr.mod.summary$method == 'kde' & hr.mod.summary$percent == '95',]
  hr.mod.summary.kde$sex <- as.character(hr.mod.summary.kde$sex)
  hr.mod.summary.kde$sex[hr.mod.summary.kde$sex == 'm'] <- 'males'
  hr.mod.summary.kde$sex[hr.mod.summary.kde$sex == 'f'] <- 'females'

## now plot with all animals
#par(mar = c(5, 6, 4, 5) + 0.1)
tabbedMeans <- tapply(hr.summary.kde$mean, list(hr.summary.kde$season, hr.summary.kde$sex), function(x) c(x = x))
tabbedSE <- tapply(hr.summary.kde$se, list(hr.summary.kde$season, hr.summary.kde$sex), function(x) c(x = x))
barCenters <- barplot(height = tabbedMeans, beside = TRUE, las = 1, ylim = c(0, 0.6), cex.names = 1,
                      main = "Porcupine home ranges", ylab = "95% KDE area (sq. km)",
                      border = "black", axes = TRUE, legend.text = TRUE,
                      args.legend = list(title = "Season", x = "topright", cex = .9))
segments(barCenters, tabbedMeans - tabbedSE, barCenters, tabbedMeans + tabbedSE, lwd = 1.5)
arrows(barCenters, tabbedMeans - tabbedSE, barCenters, tabbedMeans + tabbedSE, lwd = 1.5, angle = 90, code = 3, length = 0.05)

## now plot with only animals used in paired t-tests
tabbedMeans <- tapply(hr.mod.summary.kde$mean, list(hr.mod.summary.kde$season, hr.mod.summary.kde$sex), function(x) c(x = x))
tabbedSE <- tapply(hr.mod.summary.kde$se, list(hr.mod.summary.kde$season, hr.mod.summary.kde$sex), function(x) c(x = x))
barCenters <- barplot(height = tabbedMeans, beside = TRUE, las = 1, ylim = c(0, 0.6), cex.names = 1,
                      main = "Porcupine home ranges", ylab = "95% KDE area (sq. km)",
                      border = "black", axes = TRUE, legend.text = TRUE,
                      args.legend = list(title = "Season", x = "topright", cex = .9))
segments(barCenters, tabbedMeans - tabbedSE, barCenters, tabbedMeans + tabbedSE, lwd = 1.5)
arrows(barCenters, tabbedMeans - tabbedSE, barCenters, tabbedMeans + tabbedSE, lwd = 1.5, angle = 90, code = 3, length = 0.05)

# ---------------------------------------------------------------
## 8. Conduct t-tests (use 95% KDE for now)
# ---------------------------------------------------------------

##### female summer vs. winter
s.f <- hr.all[hr.all$sex == 'f' & hr.all$season == 'sum' & hr.all$method == 'kde' & hr.all$percent == 95,]
w.f <- hr.all[hr.all$sex == 'f' & hr.all$season == 'win' & hr.all$method == 'kde' & hr.all$percent == 95,]
s.f2 <- s.f[-c(3, 5, 6, 7),] # only keep those with both summer & winter for paired t-test

  t.test(s.f2$area, w.f$area, paired = TRUE) 
  t.test(s.f$area, w.f$area, paired = FALSE) 

## aggregate, compute standard error, plot, and add error bars
females <- rbind(w.f, s.f2)
f.summary <- aggregate(females$area, by = list(season = females$season),
                       FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
f.summary <- do.call(data.frame, f.summary) # make data frames instead of matrices
f.summary$se <- f.summary$x.sd / sqrt(f.summary$x.n)
colnames(f.summary) <- c("season", "mean", "sd", "n", "se")
barCenters <- barplot(height = f.summary$mean, names.arg = f.summary$names, beside = true, las = 2,
                      ylim = c(0, 0.6), cex.names = 0.75, xaxt = "n",
                      main = "Female home ranges",
                      ylab = "95% KDE area (sq. km)", border = "black", axes = TRUE)
text(x = barCenters, y = par("usr")[3] - 0.03, adj = 0.5, labels = f.summary$season, xpd = TRUE)
segments(barCenters, f.summary$mean - f.summary$se, barCenters, f.summary$mean + f.summary$se, lwd = 1.5)
arrows(barCenters, f.summary$mean - f.summary$se * 2, barCenters, f.summary$mean + f.summary$se * 2, lwd = 1.5, angle = 90, code = 3, length = 0.05)

##### male summer vs. winter
s.m <- hr.all[hr.all$sex == 'm' & hr.all$season == 'sum' & hr.all$method == 'kde' & hr.all$percent == 95,]
w.m <- hr.all[hr.all$sex == 'm' & hr.all$season == 'win' & hr.all$method == 'kde' & hr.all$percent == 95,]
s.m2 <- s.m[-c(2, 3, 8:9),]
  
  t.test(s.m2$area, w.m$area, paired = TRUE) 
  t.test(s.m$area, w.m$area, paired = FALSE) 

## summer female vs. male
var.test(s.f$area, s.m$area) # p>0.05; assume equal variance
t.test(s.f$area, s.m$area, var.equal = TRUE, paired = FALSE) 

## winter female vs. male
var.test(w.f$area, w.m$area) # p>0.05; assume equal variance
t.test(w.f$area, w.m$area, var.equal = TRUE, paired = FALSE) 

## overall female vs. male
all.m <- hr.all[hr.all$sex == 'm' & hr.all$season == 'all' & hr.all$method == 'kde' & hr.all$percent == 95,]
all.f <- hr.all[hr.all$sex == 'f' & hr.all$season == 'all' & hr.all$method == 'kde' & hr.all$percent == 95,]
var.test(all.f$area, all.m$area)
t.test(all.f$area, all.m$area, var.equal = TRUE, paired = FALSE) 

## both summer vs. winter
s.both <- hr.all[hr.all$season == 'sum' & hr.all$method == 'kde' & hr.all$percent == 95,]
w.both <- hr.all[hr.all$season == 'win' & hr.all$method == 'kde' & hr.all$percent == 95,]
s.both2 <- s.both[-c(4:5, 7:9, 17:18),]

t.test(s.both2$area, w.both$area, paired = TRUE) 

######### try a different way
head(hr.all)
hr.summary <- aggregate(hr.all$area, by = list(sex = hr.all$sex, season = hr.all$season),
                         FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
hr.summary <- do.call(data.frame, hr.summary) # make data frames instead of matrices

## compute standard error
hr.summary$se <- hr.summary$x.sd / sqrt(hr.summary$x.n)
colnames(hr.summary) <- c("sex", "season", "mean", "sd", "n", "se")
hr.summary$names <- c(paste(hr.summary$sex, hr.summary$season, sep = '_'))

## plot
#par(mar = c(5, 6, 4, 5) + 0.1)
plotTop <- max(hr.summary$mean) + hr.summary[hr.summary$mean == max(hr.summary$mean), 6] * 3
barCenters <- barplot(height = hr.summary$mean, names.arg = hr.summary$names, beside = true, las = 2,
                      ylim = c(0, plotTop), cex.names = 0.75, xaxt = "n",
                      main = "Porcupine home ranges",
                      ylab = "95% KDE area", border = "black", axes = TRUE)

# Specify the groupings. use srt = 45 for a 45 degree string rotation
text(x = barCenters, y = par("usr")[3] - 0.03, srt = 45, adj = 1, labels = hr.summary$names, xpd = TRUE)
segments(barCenters, hr.summary$mean - hr.summary$se, barCenters, hr.summary$mean + hr.summary$se, lwd = 1.5)
arrows(barCenters, hr.summary$mean - hr.summary$se * 2, barCenters, hr.summary$mean + hr.summary$se * 2, lwd = 1.5, angle = 90, code = 3, length = 0.05)


# ---------------------------------------------------------------
## 9. Linear regression: home range size vs. body mass 
##    - using "porc.wts" from "season-weight.R" script
##    - overall HR vs. maximum weight attained
# ---------------------------------------------------------------

max.wts <- NULL
for (i in levels(porc.wts$id)){
      wts.i <- porc.wts[porc.wts$id == i,]
      max.i <- max(wts.i$kg)
      max.wts <- rbind(max.wts, data.frame(i, max.i))      
}
max.wts$i <- as.character(max.wts$i) ## fix this earlier; shouldn't need to...
max.wts$i[max.wts$i == '15.1'] <- '15.10'
max.wts$i[max.wts$i == '16.2'] <- '16.20'
max.wts$i <- as.factor(max.wts$i)

## remove 16.16
max.wts <- max.wts[-16,]

## use overall 95% KDE
overall.hr <- hr.all[hr.all$percent == 95 & hr.all$season == 'all' & hr.all$method == 'kde',]
overall.hr$max.wt <- max.wts[match(overall.hr$id, max.wts$i), 'max.i']

## get sample sizes (# of relocations used for HR estimation)
n_locs <- stack(table(porc.locs$id))
overall.hr$n_locs <- n_locs[match(overall.hr$id, n_locs$ind), 'values']

## linear regression
m1a <- lm(area ~ max.wt, data = overall.hr)
  summary(m1a) ## moderate correlation btwn HR and body mass (r2 = 0.39, P = 0.005)
m1b <- lm(area ~ max.wt + n_locs, data = overall.hr)
  summary(m1b)

par(mar = c(5, 5, 2, 3), xpd = FALSE) #bottom, left, top, right (xpd=FALSE keeps abline inside plot area)
plot(area ~ max.wt, data = overall.hr, ylab = expression(paste('Home range area (km' ^'2', ')')), xlab = 'Body mass (kg)')
abline(m1a)

## difference between males and females?
overall.hr.f <- overall.hr[overall.hr$sex == 'f',]
overall.hr.m <- overall.hr[overall.hr$sex == 'm',]

m2 <- lm(area ~ max.wt, data = overall.hr.f)
  summary(m2a) ## no correlation btwn HR and body mass (r2 = 0.12, P = 0.325)
m2b <- lm(area ~ max.wt + n_locs, data = overall.hr.f)
  summary(m2b)  ## r2 = 0.495, P = 0.057 for n_locs, P = 0.263 for max.wt (overall P = 0.09)
  m2.selection <- glmulti(m2b, level = 1, crit = aicc)
  summary(m2.selection)
  table2 <- weightable(m2.selection)
  table2$delta_aicc <- table2$aicc - (table2$aicc[1])  

m3 <- lm(area ~ max.wt, data = overall.hr.m)
  summary(m3a) ## strong correlation btwn HR and body mass (r2 = 0.94, P < 0.001)
m3b <- lm(area ~ max.wt + n_locs, data = overall.hr.m)
  summary(m3b) ## r2 = 0.943, P = 0.607 for n_locs, P < 0.001 for max.wt (overall P < 0.001)
  m3.selection <- glmulti(m3b, level = 1, crit = aicc)
  summary(m3.selection) 
  table3 <- weightable(m3.selection)
  table3$delta_aic <- table3$aicc - (table3$aicc[1])
  
## what if we remove animals whose 'max wts' dont make much sense because they were only
  ## collared for a few months? (all were males)
m3c <- lm(area ~ max.wt, data = overall.hr.m[overall.hr.m$id != c('16.15', '16.18', '16.19', '16.20'),])
  summary(m3c) ## strong correlation btwn HR and body mass (r2 = 0.95, P < 0.027)
  ## doesn't really change things! we also tested for effect of sample size of locations (models m1b, m2b, m3b)
  
  
## both female & male plots:  
par(mfrow = c(2,1), mar = c(5,5,2,1))
plot(area ~ max.wt, data = overall.hr.f, ylab = expression(paste('Home range size (km' ^'2', ')')), xlab = 'Body mass (kg)',
     xlim = c(5.5, 11), ylim = c(0, 0.8))
  abline(m2a)
  text(10.5, 0.1, expression(paste('r' ^'2', ' = 0.12')))
  text(5.5, 0.75, 'A', font = 2, cex = 1.3)
plot(area ~ max.wt, data = overall.hr.m, ylab = expression(paste('Home range size (km' ^'2', ')')), xlab = 'Body mass (kg)',
     xlim = c(5.5, 11), ylim = c(0, 0.8))
  abline(m3a)
  text(10.5, 0.1, expression(paste('r' ^'2', ' = 0.94')))
  text(5.5, 0.75, 'B', font = 2, cex = 1.3)

## try female & male on the same plot:
par(mfrow = c(1,1), mar = c(5, 5, 2, 3), xpd = FALSE) #bottom, left, top, right (xpd=FALSE keeps abline inside plot area)
plot(area ~ max.wt, data = overall.hr.f, ylab = expression(paste('Home range size (km' ^'2', ')')), xlab = 'Body mass (kg)',
     xlim = c(5.5, 11), ylim = c(0, 0.8), pch = 19, cex = 1.5, col = 'gray60', cex.lab = 1.5, cex.axis = 1.5)
abline(m2, col = 'darkgray', lwd = 2) #female
abline(m3, col = 'black', lty = 5, lwd = 2) #male
points(area ~ max.wt, data = overall.hr.m, pch = 17, cex = 1.5, col = 'black') 
text(10.5, 0.2, expression(paste('r' ^'2', ' =0.12')), col = 'gray50', cex = 1.5)
text (10.5, 0.1, expression(paste('r' ^'2', ' =0.94')), col = 'black', cex = 1.5)
  
  
# ---------------------------------------------------------------
## 10. Miscellaneous summary stats
# ---------------------------------------------------------------  

## 9/20/16 for discussion, compute % decrease in HR from summer to winter, ala Roze (2009):
(m.mcp <- 1 - (0.075 / 0.125)) ## males, 95% mcp, winter / summer
(f.mcp <- 1 - (0.063 / 0.232))
(a.mcp <- 1 - (0.069 / 0.185)) ## all

(m.kde <- 1 - (0.219 / 0.282))
(f.kde <- 1 - (0.229 / 0.363))
(a.kde <- 1 - (0.224 / 0.327))
  
# ----------------------------------------------------------------
## 11. Export shapefile of capture locations for map
# ----------------------------------------------------------------

cap.locs <- porc.locs[porc.locs$sess == 0,]
cap.locs
cap.locs.sp <- SpatialPointsDataFrame(data.frame(cap.locs$utm_e, cap.locs$utm_n),
                               data = data.frame(cap.locs),
                               proj4string = CRS("+proj=utm +zone=10 +datum=NAD83"))
plot(cap.locs.sp)

writeOGR(cap.locs.sp, dsn = 'Shapefiles', layer = 'cap_locs', driver="ESRI Shapefile")   

# ----------------------------------------------------------------
## 12. Create table of sample sizes (per porcupine/season)
# ----------------------------------------------------------------

t <- table(porc.locs$id, porc.locs$type)

s <- table(sum.locs$id, sum.locs$type)

w <- table(win.locs$id, win.locs$type)

## read original table (to report sample sizes for all animals, even those excluded from analysis)
porc.locs.original <- read.csv('csvs/porc_locs_thesis_final.csv')
    porc.locs.original$date <- as.Date(porc.locs.original$date)

    porc.locs.original$id <- as.character(porc.locs.original$id)
    porc.locs.original$id[porc.locs.original$id == '15.1'] <- '15.10' 
    porc.locs.original$id[porc.locs.original$id == '16.2'] <- '16.20' 
    porc.locs.original$id <- as.factor(porc.locs.original$id) 

## subset locations by season (summer 2015, winter 2015-16, summer 2016)
sum15.cutoff <- '2015-11-01' 
win16.cutoff <- '2016-03-01'
    sum15.locs.original <- porc.locs.original[(porc.locs.original$date < sum15.cutoff), ]
    win15.locs.original <- porc.locs.original[(porc.locs.original$date >= sum15.cutoff) & (porc.locs.original$date < win16.cutoff), ]
    sum16.locs.original <- porc.locs.original[(porc.locs.original$date >= win16.cutoff) ,]

s15 <- table(sum15.locs.original$id, sum15.locs.original$type)

w1516 <- table(win15.locs.original$id, win15.locs.original$type)

s16 <- table(sum16.locs.original$id, sum16.locs.original$type)

# ----------------------------------------------------------------
## 13. Create figures comparing seasonal utilization distributions (UD) for each animal
##    (basically, its use of its total home range during each season)
# ----------------------------------------------------------------

par(mfrow = c(1,3), oma = c(0,0,0,0), mar = c(0,0,0,0))

## example for one animal:
## 1. 'image' shows the UD gradient (clipped to the outer 95% contour)
## 2. 'plot' adds a black outline for the 95% KDE contour (i.e., seasonal home range)
## (do this 3 times, for all, summer, winter)

image(ud.list$`16.17`$all)
  plot(contours95$`16.17`$all, add = TRUE, border = 'black', lwd = 2)
image(ud.list$`16.17`$sum)
  plot(contours95$`16.17`$sum, add = TRUE, border = 'black', lwd = 2)
image(ud.list$`16.17`$win)
  plot(contours95$`16.17`$win, add = TRUE, border = 'black', lwd = 2)

scalebar(500, xy = NULL, type = 'bar', divs = 4, below = 'meters') ## or use xy = click() to click plot to place (magic!)

## go back and run the 'par' line above to clear plot before doing another animal

# ----------------------------------------------------------------
## I removed some code from this file that is now in 'porc_homerange_extracode.R'
## It includes trying to outline the study area by combining all animal home ranges 
    ## (or by maximum distance moved) as well as overlap metrics (between animals). -CA
# ----------------------------------------------------------------