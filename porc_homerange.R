# ---------------------------------------------------------------
## Home range calculation using KDE and MCP
## Includes overlap metrics, t-tests, and body mass vs. HR size linear regression
# ---------------------------------------------------------------

library(adehabitatHR)
library(googlesheets)
library(raster)
library(rgeos)
library(reshape2)

# ---------------------------------------------------------------
## 1. First, load porcupine location data
# ---------------------------------------------------------------
gs_ls()
locs <- gs_title("Porc relocation data")
porc.vhf <- data.frame(gs_read(ss=locs, ws="Relocations", is.na(TRUE), range=cell_cols(c(1:8))))
colnames(porc.vhf) <- c("date", "id", "sess", "type", "time", "az", "utm_e", "utm_n")
porc.vhf <- subset(porc.vhf, type %in% c("V","V*","P","P*","L"))
porc.vhf$utm_e <- as.numeric(porc.vhf$utm_e)
porc.vhf$utm_n <- as.numeric(porc.vhf$utm_n)
## check date format before running either line 51 or 52
porc.vhf$date <- as.Date(porc.vhf$date, "%m/%d/%Y") 
#porc.vhf$date <- as.Date(porc.vhf$date, origin = as.Date("1899-12-30"))

## Incorporate GPS data (1 random point per day)
porc.gps <- read.csv('csvs/daily_gps_090416.csv') ## generated by 'gps_clean_IA.R'
porc.gps$type <- rep("gps", nrow(porc.gps))
porc.gps$az <- rep(NA, nrow(porc.gps))
porc.gps$Animal.ID <- as.character(porc.gps$Animal.ID)
porc.gps$Animal.ID[porc.gps$Animal.ID == '16.2'] <- '16.20' ## why do I have to do this?
porc.gps.df <- data.frame(porc.gps$Date, porc.gps$Animal.ID, porc.gps$Session, porc.gps$type,
                          porc.gps$Time, porc.gps$az, porc.gps$UTM.E, porc.gps$UTM.N)
colnames(porc.gps.df) <- colnames(porc.vhf)
porc.gps.df$date <- as.Date(porc.gps.df$date, "%Y-%m-%d")
porc.gps.df$id <- as.factor(porc.gps.df$id)

## combine VHF with GPS points
porc.locs <- rbind(porc.vhf, porc.gps.df)

## remove 16.19 for now... even though it has >4 locations, grid is too small for kernelUD step
## and 15.04?
#porc.locs <- porc.locs[porc.locs$id != '16.19',]

## subset summer locations (before Nov 1 or after March 1) and winter (between Nov 1 and March 1)
sum.locs <- porc.locs[(porc.locs$date < "2015-11-01") | (porc.locs$date >= "2016-03-01"), ]
win.locs <- porc.locs[(porc.locs$date >= "2015-11-01") & (porc.locs$date < "2016-03-01"), ]

## Keep only animals with >= 5 locations in each season (and overall; this only applies to 16.16)
n <- table(sum.locs$id)
sum.locs <- subset(sum.locs, id %in% names(n[n >= 5]), drop=TRUE)
sum.locs <- droplevels(sum.locs)

n <- table(win.locs$id)
win.locs <- subset(win.locs, id %in% names(n[n >= 5]), drop=TRUE)
win.locs <- droplevels(win.locs)

n <- table(porc.locs$id)
porc.locs <- subset(porc.locs, id %in% names(n[n >= 5]), drop=TRUE)
porc.locs <- droplevels(porc.locs)

# ---------------------------------------------------------------
## 2. Then, extract the UD from "adehabitatHR" package
# ---------------------------------------------------------------

## Calculate grid & extent based on desired cell size (# meters on each side)
## For for each animal separately 

ids <- unique(porc.locs$id)
kde.areas <- list()
kud.all <- list()
overlap <- list()
contours <- list()

for (i in ids){
        locs.i <- porc.locs[porc.locs$id == i,]
        locs.i$id_season <- rep(paste(i, "_all", sep = ""), nrow(locs.i))
        locs.sum.i <- sum.locs[sum.locs$id == i,]
        locs.sum.i$id_season <- rep(paste(i, "_sum", sep = ""), nrow(locs.sum.i))
        locs.win.i <- win.locs[win.locs$id == i,]
        locs.win.i$id_season <- rep(paste(i, "_win", sep = ""), nrow(locs.win.i))
        locs.all.i <- rbind(locs.i, locs.sum.i, locs.win.i)
        sp.i <- SpatialPointsDataFrame(data.frame(locs.all.i$utm_e, locs.all.i$utm_n),
                                       data=data.frame(locs.all.i$id_season),
                                       proj4string=CRS("+proj=utm +zone=10 +datum=NAD83"))
        c = 10   ## desired cell size (meters)
        fake.kern <- kernelUD(xy = sp.i, extent = 1)
        spdf <- raster(as(fake.kern[[1]], "SpatialPixelsDataFrame"))
        eas <- diff(range(spdf@extent[1:2]))
        nor <- diff(range(spdf@extent[3:4]))
        if(eas > nor){
          g <- (eas/c)
        } else {
          g <- (nor/c)
        }
        # calculate UD on all IDs ("all", "winter", and "summer") with same4all = TRUE
        kern.i <- kernelUD(xy = sp.i, h = 60, grid = g, extent = 1, same4all = TRUE)
        kde.i <- kernel.area(kern.i, percent = c(50, 90, 95, 99), unin = "m", unout = "km2", standardize = FALSE)
        data.frame(kde.i, row.names = c("50", "90", "95", "99"))
        kde.areas[[i]] <- kde.i
        kud.all[[i]] <- kern.i
        
        # calculate overlap using UDOI method ('UD overlap index' from Fieberg and Kochanny 2010)
        if (length(kern.i) > 2){
        overlap.i <- kerneloverlaphr(kern.i, method = 'UDOI', percent = 95, conditional = TRUE)
        overlap[[i]] <- overlap.i # store comparisons between overall/summer/winter for each animal
        }
        # make 95% contours (full and summer)
        cont95 <- list()
        for (j in names(kern.i)){
            cont95.i <- getverticeshr.estUD(kern.i[[j]], percent = 95, unin = "m", unout = "km2", standardize = FALSE)
            cont95[[j]] <- cont95.i
        }
        contours[[i]] <- cont95
}

# ---------------------------------------------------------------
## 3. Try overall home range for all animals combined to outline study area
##    - should remove outliers (15.04 dispersal, 15.06 exploratory)
# ---------------------------------------------------------------

locs.all <- porc.locs ## to create SPDF
locs.all$id2 <- rep('all', nrow(locs.all))
sp.all <- SpatialPointsDataFrame(data.frame(locs.all$utm_e, locs.all$utm_n),
                                 data=data.frame(locs.all$id2),
                                 proj4string=CRS("+proj=utm +zone=10 +datum=NAD83"))

veg_buf <- gBuffer(veg, byid = FALSE, width = 200) ## buffer 200 m around study area
plot(sp.all)
plot(veg_buf, add = TRUE, border = 'red')

sp.all.clip <- sp.all[veg_buf,] ## clip points to buffered study area to remove outliers

c = 10   ## desired cell size (meters)
fake.kern <- kernelUD(xy = sp.all.clip, extent = 1)
spdf <- raster(as(fake.kern[[1]], "SpatialPixelsDataFrame"))
  eas <- diff(range(spdf@extent[1:2]))
  nor <- diff(range(spdf@extent[3:4]))
  if(eas > nor){
    g <- (eas/c)
  } else {
    g <- (nor/c)
  }
  # calculate UD on all IDs ("all", "winter", and "summer") with same4all = TRUE
  kern.i <- kernelUD(xy = sp.all.clip, h = 60, grid = g, extent = 1, same4all = TRUE)
  kde.i <- kernel.area(kern.i, percent = c(50, 90, 95, 99), unin = "m", unout = "km2", standardize = FALSE)
  data.frame(kde.i, row.names = c("50", "90", "95", "99"))
kud.allporcs <- kern.i
kde.allporcs <- kde.i
  
# make contours
cont95.all <- getverticeshr.estUDm(kern.i, percent = 99, unin = "m", unout = "km2", standardize = FALSE)
plot(cont95.all) ## looks too restrictive. try 99%, increasing bandwidth, or using MCP.

# try MCP
mcp.all <- mcp(sp.all.clip, percent = 100, unin="m", unout="km2")
plot(mcp.all, main="95% MCP, All")
mcp.all95.df <- data.frame(mcp.all95$id, rep('95', nrow(mcp.all95)), mcp.all95$area,
                           rep('all', nrow(mcp.all95)), rep('mcp', nrow(mcp.all95)))

### Try by max distance moved (other than outliers)
ids <- unique(porc.locs$id)
max.dist <- NULL

for (i in ids){
  max <- 0
  cur.dist <- NULL
  locs.i <- porc.locs[porc.locs$id == i,]
  for(j in 1:nrow(locs.i)){
    cur.pt <- locs.i[j,]
    for(k in 1:nrow(locs.i)){
      compare.pt <- locs.i[k,]
      cur.dist <- sqrt((cur.pt$utm_e - compare.pt$utm_e)^2+(cur.pt$utm_n - compare.pt$utm_n)^2)
      if(cur.dist > max){
        max <- cur.dist
      }
    }
  }
  max.dist <- rbind(max.dist, data.frame(max, i))
}

max.dist ## for each animal
max.dist <- max.dist[-c(4, 6),] ## remove 15.04 and 15.06
max <- max(max.dist$max) ## overall (in meters)

# Now buffer all the points
study.area <- gBuffer(sp.all.clip, width = max)
plot(study.area)

# ---------------------------------------------------------------
## 4. Organize list of KDE areas
# ---------------------------------------------------------------

ids <- names(kde.areas)
kde.all <- NULL
for(i in ids){
    kdes.i <- NULL
  for (j in names(kde.areas[[i]])){
        kde <- (kde.areas[[i]])[j]
        kde$season <- rep(substr(j, start = 8, stop = 10), nrow(kde))
        kde$method <- rep('kde', nrow(kde))
        colnames(kde) <- c('km2', 'season', 'method')
        per <- c('50', '90', '95', '99')
        kde.df <- data.frame(i, per, kde$km2, kde$season, kde$method)
        colnames(kde.df) <- c('id', 'percent', 'area', 'season', 'method')
        kdes.i <- rbind(kdes.i, kde.df)
        }
      kde.all <- rbind(kde.all, kdes.i)    
}

# ---------------------------------------------------------------
## 5. Manipulate list of overlap metrices & do comparisons
# ---------------------------------------------------------------

ids <- names(overlap)
overlap.all <- NULL
for(i in ids){
    overlap.i <- overlap[[i]] ## only keep those with both sum & win for comparisons
  if (nrow(overlap.i) > 2){
    all <- stack(overlap.i[,1])
    all$s2 <- 'all'
    sum <- stack(overlap.i[,2])
    sum$s2 <- 'sum'
    win <- stack(overlap.i[,3])
    win$s2 <- 'win'
    overlap.df <- rbind(all, sum, win)
    overlap.df$id <- i
    overlap.df$s1 <- substr(overlap.df$ind, 7, 9)
  }
    overlap.all <- rbind(overlap.all, overlap.df[,c(4, 5, 3, 1)])
}

all.all <- overlap.all[overlap.all$s1 == 'all' & overlap.all$s2 == 'all',]
sum.all <- overlap.all[overlap.all$s1 == 'sum' & overlap.all$s2 == 'all',]
win.all <- overlap.all[overlap.all$s1 == 'win' & overlap.all$s2 == 'all',]
sum.win <- overlap.all[overlap.all$s1 == 'sum' & overlap.all$s2 == 'win',]

overlap.means <- c(mean(sum.all$values), mean(win.all$values), mean(sum.win$values))
overlap.se <- c(sd(sum.all$values)/sqrt(nrow(sum.all)), sd(win.all$values)/sqrt(nrow(win.all)), sd(sum.win$values)/sqrt(nrow(sum.win)))
comparisons <- c('sum_all', 'win_all', 'sum_win')
overlaps <- data.frame('comp' = comparisons, 'mean' = overlap.means, 'se' = overlap.se)

t.test(sum.all$values, win.all$values, paired = TRUE, alternative = 'greater')
t.test(sum.win$values, sum.all$values, paired = TRUE, alternative = 'less')
t.test(sum.win$values, win.all$values, paired = TRUE, alternative = 'less')

## Calculate overlap between males and females during summer & winter
## need to re-run UDs on same grid in order to compare; 'kerneloverlap' includes this step, but input 'grid' parameter
sum.sp <- SpatialPointsDataFrame(data.frame(sum.locs$utm_e, sum.locs$utm_n),
                               data = data.frame(sum.locs$id),
                               proj4string=CRS("+proj=utm +zone=10 +datum=NAD83"))
win.sp <- SpatialPointsDataFrame(data.frame(win.locs$utm_e, win.locs$utm_n),
                               data = data.frame(win.locs$id),
                               proj4string=CRS("+proj=utm +zone=10 +datum=NAD83"))

overlap.sum <- kerneloverlap(sum.sp, method = 'UDOI', percent = 95, conditional = TRUE, 
                              h = 60, grid = 535.7288, extent = 1) ## 535.7288 is 'g' from above code using 'sum.locs'
overlap.win <- kerneloverlap(win.sp, method = 'UDOI', percent = 95, conditional = TRUE, 
                              h = 60, grid = 176.9492, extent = 1) ## 535.7288 is 'g' from above code using 'win.locs'

## can't do means on these because there are lots of redundancies (will inflate n)
sum.melt <- melt(overlap.sum, varnames = c('row', 'col'), na.rm = TRUE)
  sum.unique <- unique(t(apply(sum.melt, 1, sort)))
  overlap.s <- sum.unique[(sum.unique[,2] != sum.unique[,3]),] ## good; 136 pair combinations (17 animals)
  overlap.s.nonzero <- data.frame(overlap.s[(overlap.s[,1] != 0),])
  
win.melt <- melt(overlap.win, varnames = c('row', 'col'), na.rm = TRUE)
  win.unique <- unique(t(apply(win.melt, 1, sort)))
  overlap.w <- win.unique[(win.unique[,2] != win.unique[,3]),] ## good; 55 pair combinations (11 animals)
  overlap.w.nonzero <-   data.frame(overlap.w[(overlap.w[,1] != 0),])

overlap.means <- c(mean(overlap.s.nonzero[,1]), mean(overlap.w.nonzero[,1]))
overlap.se <- c(sd(overlap.s.nonzero[,1])/sqrt(nrow(overlap.s.nonzero)), sd(overlap.w.nonzero[,1])/sqrt(nrow(overlap.w.nonzero))) ## or should sample sizes be 17 and 7?
comparisons <- c('summer', 'winter')
overlaps <- data.frame('comp' = comparisons, 'mean' = overlap.means, 'se' = overlap.se)

## add m/f
sex <- c('f', 'f', 'm', 'm', 'f', 'm', 'f', 'f', 'f', 'f', 'm', 'f', 'f', 'm', 'm', 'f', 'm', 'm', 'm')
sex_key <- data.frame('id' = as.numeric(rownames(overlap.sum)), 'sex' = sex) ## as.numeric to match with below... otherwise get '15.1'... figure this out

overlap.s.nonzero$sex1 <- sex_key[match(overlap.s.nonzero$X2, sex_key$id), 'sex'] 
  overlap.s.nonzero$sex2 <- sex_key[match(overlap.s.nonzero$X3, sex_key$id), 'sex'] 
overlap.w.nonzero$sex1 <- sex_key[match(overlap.w.nonzero$X2, sex_key$id), 'sex']
  overlap.w.nonzero$sex2 <- sex_key[match(overlap.w.nonzero$X3, sex_key$id), 'sex']

mean.s.ff <- mean(overlap.s.nonzero$X1[overlap.s.nonzero$sex1 == 'f' & overlap.s.nonzero$sex2 == 'f'])
mean.s.mm <- mean(overlap.s.nonzero$X1[overlap.s.nonzero$sex1 == 'm' & overlap.s.nonzero$sex2 == 'm'])
mean.s.fm <- mean(overlap.s.nonzero$X1[overlap.s.nonzero$sex1 != overlap.s.nonzero$sex2])

## Now look at overlap between core areas only (50% KDEs)
overlap50.sum <- kerneloverlap(sum.sp, method = 'UDOI', percent = 50, conditional = TRUE, 
                             h = 60, grid = 535.7288, extent = 1) ## 535.7288 is 'g' from above code using 'sum.locs'
overlap50.win <- kerneloverlap(win.sp, method = 'UDOI', percent = 50, conditional = TRUE, 
                             h = 60, grid = 176.9492, extent = 1) ## 535.7288 is 'g' from above code using 'win.locs'

## can't do means on these because there are lots of redundancies (will inflate n)
sum.melt50 <- melt(overlap50.sum, varnames = c('row', 'col'), na.rm = TRUE)
sum.unique50 <- unique(t(apply(sum.melt50, 1, sort)))
overlap.s50 <- sum.unique50[(sum.unique50[,2] != sum.unique50[,3]),] ## good; 136 pair combinations (17 animals)
overlap.s.nonzero50 <- data.frame(overlap.s50[(overlap.s50[,1] != 0),])

win.melt50 <- melt(overlap50.win, varnames = c('row', 'col'), na.rm = TRUE)
win.unique50 <- unique(t(apply(win.melt50, 1, sort)))
overlap.w50 <- win.unique50[(win.unique50[,2] != win.unique50[,3]),] ## good; 55 pair combinations (11 animals)
overlap.w.nonzero50 <-   data.frame(overlap.w50[(overlap.w50[,1] != 0),])

overlap.means50 <- c(mean(overlap.s.nonzero50[,1]), mean(overlap.w.nonzero50[,1]))
overlap.se50 <- c(sd(overlap.s.nonzero50[,1])/sqrt(nrow(overlap.s.nonzero50)), sd(overlap.w.nonzero50[,1])/sqrt(nrow(overlap.w.nonzero50))) ## or should sample sizes be 17 and 7?
comparisons <- c('summer', 'winter')
overlaps50 <- data.frame('comp' = comparisons, 'mean' = overlap.means50, 'se' = overlap.se50)

## add m/f
sex <- c('f', 'f', 'm', 'm', 'f', 'm', 'f', 'f', 'f', 'f', 'm', 'f', 'f', 'm', 'm', 'f', 'm', 'm', 'm')
sex_key <- data.frame('id' = as.numeric(rownames(overlap.sum)), 'sex' = sex) ## as.numeric to match with below... otherwise get '15.1'... figure this out

overlap.s.nonzero50$sex1 <- sex_key[match(overlap.s.nonzero50$X2, sex_key$id), 'sex'] 
overlap.s.nonzero50$sex2 <- sex_key[match(overlap.s.nonzero50$X3, sex_key$id), 'sex'] 
overlap.w.nonzero50$sex1 <- sex_key[match(overlap.w.nonzero50$X2, sex_key$id), 'sex']
overlap.w.nonzero50$sex2 <- sex_key[match(overlap.w.nonzero50$X3, sex_key$id), 'sex']

mean.s.ff50 <- mean(overlap.s.nonzero50$X1[overlap.s.nonzero50$sex1 == 'f' & overlap.s.nonzero50$sex2 == 'f'])
mean.s.mm50 <- mean(overlap.s.nonzero50$X1[overlap.s.nonzero50$sex1 == 'm' & overlap.s.nonzero50$sex2 == 'm'])
mean.s.fm50 <- mean(overlap.s.nonzero50$X1[overlap.s.nonzero50$sex1 != overlap.s.nonzero50$sex2])

### ok, 'overlaps' tells us means. so more overlapped during winter than summer...?
## how many overlapped at all? what was the highest/lowest overlap between a pair?
## next do males / females

# ---------------------------------------------------------------
## 6. Quick plot of home ranges
# ---------------------------------------------------------------

f <- c('15.01', '15.02', '15.05', '15.07', '15.08', '15.09', '15.10', '15.12', '15.13', '16.16', '16.17')
m <- c('15.03', '15.04', '15.06', '15.11', '15.14', '16.15', '16.18')
plot(veg.ext)
for (i in f){
  plot(contours[[i]][[2]], add = TRUE, lty = 1, lwd = 2)
}

for (i in names(contours)){ 
  contours.i <- contours[[i]]  
    for (j in names(contours.i)){ 
      myname <- paste(j, '95kde', sep = '_')
      writeOGR(contours.i[[j]], dsn = 'Shapefiles/home_ranges_090816', layer = myname, driver="ESRI Shapefile")
    }
}

# ---------------------------------------------------------------
## 7. Calculate MCP and export as CSV
# ---------------------------------------------------------------

## all points
all.df <- data.frame(porc.locs$utm_e, porc.locs$utm_n, porc.locs$id, porc.locs$date)
colnames(all.df) <- c("x", "y", "id", "date")
all.spdf <- SpatialPointsDataFrame(data.frame(all.df$x, all.df$y),
                                   data=data.frame(all.df$id),
                                   proj4string=CRS("+proj=utm +zone=10 +datum=NAD83"))

mcp.all95 <- mcp(all.spdf, percent = 95, unin="m", unout="km2")
plot(mcp.all95, main="95% MCP, All")
mcp.all95.df <- data.frame(mcp.all95$id, rep('95', nrow(mcp.all95)), mcp.all95$area,
                           rep('all', nrow(mcp.all95)), rep('mcp', nrow(mcp.all95)))
colnames(mcp.all95.df) <- c('id', 'percent', 'area', 'season', 'method')
write.csv(mcp.all95.df, "csvs/mcp_all_95_091016.csv")

## summer
sum.df <- data.frame(sum.locs$utm_e, sum.locs$utm_n, sum.locs$id, sum.locs$date)
colnames(sum.df) <- c("x", "y", "id", "date")
sum.spdf <- SpatialPointsDataFrame(data.frame(sum.df$x, sum.df$y),
                                   data = data.frame(sum.df$id),
                                   proj4string = CRS("+proj=utm +zone=10 +datum=NAD83"))
mcp.sum95 <- mcp(sum.spdf, percent = 95, unin = 'm', unout = 'km2')
plot(mcp.sum95, main = '95% MCP, Summer')
mcp.sum95.df <- data.frame(mcp.sum95$id, rep('95', nrow(mcp.sum95)), mcp.sum95$area,
                           rep('sum', nrow(mcp.sum95)), rep('mcp', nrow(mcp.sum95)))
colnames(mcp.sum95.df) <- c('id', 'percent', 'area', 'season', 'method')
write.csv(mcp.sum95.df, "csvs/mcp_sum_95_091016.csv")

## winter
win.df <- data.frame(win.locs$utm_e, win.locs$utm_n, win.locs$id, win.locs$date)
colnames(win.df) <- c("x", "y", "id", "date")
win.spdf <- SpatialPointsDataFrame(data.frame(win.df$x, win.df$y),
                                   data = data.frame(win.df$id),
                                   proj4string = CRS("+proj=utm +zone=10 +datum=NAD83"))
mcp.win95 <- mcp(win.spdf, percent = 95, unin = 'm', unout = 'km2')
plot(mcp.win95, main = '95% MCP, Winter')
mcp.win95.df <- data.frame(mcp.win95$id, rep('95', nrow(mcp.win95)), mcp.win95$area,
                           rep('win', nrow(mcp.win95)), rep('mcp', nrow(mcp.win95)))
colnames(mcp.win95.df) <- c('id', 'percent', 'area', 'season', 'method')
write.csv(mcp.win95.df, "csvs/mcp_win_95_091016.csv")

mcp.all <- rbind(mcp.all95.df, mcp.sum95.df, mcp.win95.df)

# ---------------------------------------------------------------
## 8. Now do analysis
# ---------------------------------------------------------------

hr.all <- rbind(kde.all, mcp.all) # combine MCP and KDE
hr.all$sex[hr.all$id %in% c('15.01', '15.02', '15.05', '15.07', '15.08', '15.09', '15.10', '15.12', '15.13', '16.16', '16.17')] <- 'f'
hr.all$sex[hr.all$id %in% c('15.03', '15.04', '15.06', '15.11', '15.14', '16.15', '16.18', '16.19', '16.20')] <- 'm'

## remove 15.04 (home range may represent dispersal...)
hr.all <- hr.all[hr.all$id != '15.04',]

## aggregate and compute SE
hr.summary <- aggregate(hr.all$area, by = list(sex = hr.all$sex, season = hr.all$season, method = hr.all$method, percent = hr.all$percent),
                        FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
hr.summary <- do.call(data.frame, hr.summary) # make data frames instead of matrices
colnames(hr.summary) <- c('sex', 'season', 'method', 'percent', 'mean', 'sd', 'n')
hr.summary$se <- hr.summary$sd / sqrt(hr.summary$n)
hr.summary$names <- c(paste(hr.summary$sex, hr.summary$season, sep = '_'))
write.csv(hr.summary, 'csvs/homeranges091016.csv')

## mean and SE of both males/females (b/c not computed automatically in aggregate)
all.sum.50kde <- hr.all[hr.all$percent == 50 & hr.all$method == 'kde' & hr.all$season == 'sum',]$area
  mean(all.sum.50kde)
  (n <- length(all.sum.50kde))
  sd(all.sum.50kde) / n
all.win.50kde <- hr.all[hr.all$percent == 50 & hr.all$method == 'kde' & hr.all$season == 'win',]$area
  mean(all.win.50kde)
  (n <- length(all.win.50kde))
  sd(all.win.50kde) / n
all.sum.90kde <- hr.all[hr.all$percent == 90 & hr.all$method == 'kde' & hr.all$season == 'sum',]$area
  mean(all.sum.90kde)
  (n <- length(all.sum.90kde))
  sd(all.sum.90kde) / n
all.win.90kde <- hr.all[hr.all$percent == 90 & hr.all$method == 'kde' & hr.all$season == 'win',]$area
  mean(all.win.90kde)
  (n <- length(all.win.90kde))
  sd(all.win.90kde) / n
all.sum.95kde <- hr.all[hr.all$percent == 95 & hr.all$method == 'kde' & hr.all$season == 'sum',]$area
  mean(all.sum.95kde)
  (n <- length(all.sum.95kde))
  sd(all.sum.95kde) / n
all.win.95kde <- hr.all[hr.all$percent == 95 & hr.all$method == 'kde' & hr.all$season == 'win',]$area
  mean(all.win.95kde)
  (n <- length(all.win.95kde))
  sd(all.win.95kde) / n
all.sum.95mcp <- hr.all[hr.all$percent == 95 & hr.all$method == 'mcp' & hr.all$season == 'sum',]$area
  mean(all.sum.95mcp)
  (n <- length(all.sum.95mcp))
  sd(all.sum.95mcp) / n
all.win.95mcp <- hr.all[hr.all$percent == 95 & hr.all$method == 'mcp' & hr.all$season == 'win',]$area
  mean(all.win.95mcp)
  (n <- length(all.win.95mcp))
  sd(all.win.95mcp) / n
  
## both seasons, both sexes (not in aggregate)
all.all.50kde <- hr.all[hr.all$percent == 50 & hr.all$method == 'kde' & hr.all$season == 'all',]$area
  mean(all.all.50kde)
  (n <- length(all.all.50kde))
  sd(all.all.50kde) / n 
all.all.90kde <- hr.all[hr.all$percent == 90 & hr.all$method == 'kde' & hr.all$season == 'all',]$area
  mean(all.all.90kde)
  (n <- length(all.all.90kde))
  sd(all.all.90kde) / n 
all.all.95kde <- hr.all[hr.all$percent == 95 & hr.all$method == 'kde' & hr.all$season == 'all',]$area
  mean(all.all.95kde)
  (n <- length(all.all.95kde))
  sd(all.all.95kde) / n
all.all.95mcp <- hr.all[hr.all$percent == 95 & hr.all$method == 'mcp' & hr.all$season == 'all',]$area
  mean(all.all.95mcp)
  (n <- length(all.all.95mcp))
  sd(all.all.95mcp) / n 

## now do this all over again using ONLY animals with both summer and winter home ranges
## b/c these are the ones used in paired t-tests below
## (Just out of curiousity. I report the above values--all porcupines--in results.)

hr.all.mod <- subset(hr.all, id %in% c('15.01', '15.02', '15.03', '15.07', '15.11', '15.12', '15.13', '15.14', '16.15', '16.17', '16.18'), drop = TRUE)
hr.all.mod$id <- droplevels(hr.all.mod$id)
hr.mod.summary <- aggregate(hr.all.mod$area, by = list(sex = hr.all.mod$sex, season = hr.all.mod$season, method = hr.all.mod$method, percent = hr.all.mod$percent),
                        FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
hr.mod.summary <- do.call(data.frame, hr.mod.summary) # make data frames instead of matrices
colnames(hr.mod.summary) <- c('sex', 'season', 'method', 'percent', 'mean', 'sd', 'n')
hr.mod.summary$se <- hr.mod.summary$sd / sqrt(hr.mod.summary$n)
hr.mod.summary$names <- c(paste(hr.mod.summary$sex, hr.mod.summary$season, sep = '_'))
write.csv(hr.mod.summary, 'csvs/homeranges_mod091016.csv')

# ---------------------------------------------------------------
## 9. Now make plots
# ---------------------------------------------------------------

## first, subset only 95% KDEs
hr.summary.kde <- hr.summary[hr.summary$method == 'kde' & hr.summary$percent == '95',]
hr.summary.kde$sex <- as.character(hr.summary.kde$sex)
hr.summary.kde$sex[hr.summary.kde$sex == 'm'] <- 'males'
hr.summary.kde$sex[hr.summary.kde$sex == 'f'] <- 'females'

hr.mod.summary.kde <- hr.mod.summary[hr.mod.summary$method == 'kde' & hr.mod.summary$percent == '95',]
hr.mod.summary.kde$sex <- as.character(hr.mod.summary.kde$sex)
hr.mod.summary.kde$sex[hr.mod.summary.kde$sex == 'm'] <- 'males'
hr.mod.summary.kde$sex[hr.mod.summary.kde$sex == 'f'] <- 'females'

## now plot with all animals
#par(mar = c(5, 6, 4, 5) + 0.1)
tabbedMeans <- tapply(hr.summary.kde$mean, list(hr.summary.kde$season, hr.summary.kde$sex), function(x) c(x = x))
tabbedSE <- tapply(hr.summary.kde$se, list(hr.summary.kde$season, hr.summary.kde$sex), function(x) c(x = x))
barCenters <- barplot(height = tabbedMeans, beside = TRUE, las = 1, ylim = c(0, 0.6), cex.names = 1,
                      main = "Porcupine home ranges", ylab = "95% KDE area (sq. km)",
                      border = "black", axes = TRUE, legend.text = TRUE,
                      args.legend = list(title = "Season", x = "topright", cex = .9))
segments(barCenters, tabbedMeans - tabbedSE, barCenters, tabbedMeans + tabbedSE, lwd = 1.5)
arrows(barCenters, tabbedMeans - tabbedSE, barCenters, tabbedMeans + tabbedSE, lwd = 1.5, angle = 90, code = 3, length = 0.05)

## now plot with only animals used in paired t-tests
tabbedMeans <- tapply(hr.mod.summary.kde$mean, list(hr.mod.summary.kde$season, hr.mod.summary.kde$sex), function(x) c(x = x))
tabbedSE <- tapply(hr.mod.summary.kde$se, list(hr.mod.summary.kde$season, hr.mod.summary.kde$sex), function(x) c(x = x))
barCenters <- barplot(height = tabbedMeans, beside = TRUE, las = 1, ylim = c(0, 0.6), cex.names = 1,
                      main = "Porcupine home ranges", ylab = "95% KDE area (sq. km)",
                      border = "black", axes = TRUE, legend.text = TRUE,
                      args.legend = list(title = "Season", x = "topright", cex = .9))
segments(barCenters, tabbedMeans - tabbedSE, barCenters, tabbedMeans + tabbedSE, lwd = 1.5)
arrows(barCenters, tabbedMeans - tabbedSE, barCenters, tabbedMeans + tabbedSE, lwd = 1.5, angle = 90, code = 3, length = 0.05)

# ---------------------------------------------------------------
## 10. t-tests: use 95% KDE for now
# ---------------------------------------------------------------

##### female summer vs. winter
s.f <- hr.all[hr.all$sex == 'f' & hr.all$season == 'sum' & hr.all$method == 'kde' & hr.all$percent == 95,]
w.f <- hr.all[hr.all$sex == 'f' & hr.all$season == 'win' & hr.all$method == 'kde' & hr.all$percent == 95,]
s.f2 <- s.f[-c(3, 5, 6, 7),] # only keep those with both summer & winter for paired t-test

t.test(s.f2$area, w.f$area, paired = TRUE) # n = 6
t.test(s.f$area, w.f$area, paired = FALSE) # n = 10 / 6

## aggregate, compute standard error, plot, and add error bars
females <- rbind(w.f, s.f2)
f.summary <- aggregate(females$area, by = list(season = females$season),
                       FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
f.summary <- do.call(data.frame, f.summary) # make data frames instead of matrices
f.summary$se <- f.summary$x.sd / sqrt(f.summary$x.n)
colnames(f.summary) <- c("season", "mean", "sd", "n", "se")
barCenters <- barplot(height = f.summary$mean, names.arg = f.summary$names, beside = true, las = 2,
                      ylim = c(0, 0.6), cex.names = 0.75, xaxt = "n",
                      main = "Female home ranges",
                      ylab = "95% KDE area (sq. km)", border = "black", axes = TRUE)
text(x = barCenters, y = par("usr")[3] - 0.03, adj = 0.5, labels = f.summary$season, xpd = TRUE)
segments(barCenters, f.summary$mean - f.summary$se, barCenters, f.summary$mean + f.summary$se, lwd = 1.5)
arrows(barCenters, f.summary$mean - f.summary$se * 2, barCenters, f.summary$mean + f.summary$se * 2, lwd = 1.5, angle = 90, code = 3, length = 0.05)

##### male summer vs. winter
s.m <- hr.all[hr.all$sex == 'm' & hr.all$season == 'sum' & hr.all$method == 'kde' & hr.all$percent == 95,]
w.m <- hr.all[hr.all$sex == 'm' & hr.all$season == 'win' & hr.all$method == 'kde' & hr.all$percent == 95,]
s.m2 <- s.m[-c(2, 3, 8:9),]

t.test(s.m2$area, w.m$area, paired = TRUE) # n = 5
t.test(s.m$area, w.m$area, paired = FALSE) # n = 5 / 6

## summer female vs. male
t.test(s.f$area, s.m$area, paired = FALSE) # n = 10 / 6

## winter female vs. male
t.test(w.f$area, w.m$area, paired = FALSE) # n = 6 / 5

## overall female vs. male
all.m <- hr.all[hr.all$sex == 'm' & hr.all$season == 'all' & hr.all$method == 'kde' & hr.all$percent == 95,]
all.f <- hr.all[hr.all$sex == 'f' & hr.all$season == 'all' & hr.all$method == 'kde' & hr.all$percent == 95,]
t.test(all.f$area, all.m$area, paired = FALSE) # n = 8 / 10

## both summer vs. winter
s.both <- hr.all[hr.all$season == 'sum' & hr.all$method == 'kde' & hr.all$percent == 95,]
w.both <- hr.all[hr.all$season == 'win' & hr.all$method == 'kde' & hr.all$percent == 95,]
s.both2 <- s.both[-c(4:5, 7:9, 17:18),]

t.test(s.both2$area, w.both$area, paired = TRUE) # n = 11
t.test(s.both$area, w.both$area, paired = FALSE) # n = 16 / 11

######### try a different way
head(hr.all)
hr.summary <- aggregate(hr.all$area, by = list(sex = hr.all$sex, season = hr.all$season),
                         FUN = function(x) c(mean = mean(x), sd = sd(x), n = length(x)))
hr.summary <- do.call(data.frame, hr.summary) # make data frames instead of matrices

## compute standard error
hr.summary$se <- hr.summary$x.sd / sqrt(hr.summary$x.n)
colnames(hr.summary) <- c("sex", "season", "mean", "sd", "n", "se")
hr.summary$names <- c(paste(hr.summary$sex, hr.summary$season, sep = '_'))

## plot
#par(mar = c(5, 6, 4, 5) + 0.1)
plotTop <- max(hr.summary$mean) + hr.summary[hr.summary$mean == max(hr.summary$mean), 6] * 3
barCenters <- barplot(height = hr.summary$mean, names.arg = hr.summary$names, beside = true, las = 2,
                      ylim = c(0, plotTop), cex.names = 0.75, xaxt = "n",
                      main = "Porcupine home ranges",
                      ylab = "95% KDE area", border = "black", axes = TRUE)

# Specify the groupings. use srt = 45 for a 45 degree string rotation
text(x = barCenters, y = par("usr")[3] - 0.03, srt = 45, adj = 1, labels = hr.summary$names, xpd = TRUE)
segments(barCenters, hr.summary$mean - hr.summary$se, barCenters, hr.summary$mean + hr.summary$se, lwd = 1.5)
arrows(barCenters, hr.summary$mean - hr.summary$se * 2, barCenters, hr.summary$mean + hr.summary$se * 2, lwd = 1.5, angle = 90, code = 3, length = 0.05)


# ---------------------------------------------------------------
## 11. Linear regression: home range size vs. body mass 
##    - using "porc.wts" from "season-weight.R" script
##    -(overall HR vs. maximum weight attained)
# ---------------------------------------------------------------

max.wts <- NULL
for (i in levels(porc.wts$id)){
      wts.i <- porc.wts[porc.wts$id == i,]
      max.i <- max(wts.i$kg)
      max.wts <- rbind(max.wts, data.frame(i, max.i))      
}
max.wts$i <- as.character(max.wts$i) ## fix this earlier; shouldn't need to...
max.wts$i[max.wts$i == '15.1'] <- '15.10'
max.wts$i[max.wts$i == '16.2'] <- '16.20'
max.wts$i <- as.factor(max.wts$i)

## use overall 95% KDE
overall.hr <- hr.all[hr.all$percent == 95 & hr.all$season == 'all' & hr.all$method == 'kde',]
overall.hr$max.wt <- max.wts[match(overall.hr$id, max.wts$i), 'max.i']

## get sample sizes (# of relocations used for HR estimation)
n_locs <- stack(table(porc.locs$id))
overall.hr$n_locs <- n_locs[match(overall.hr$id, n_locs$ind), 'values']

## linear regression
m1 <- lm(area ~ max.wt, data = overall.hr)
summary(m1) ## moderate correlation btwn HR and body mass (r2 = 0.39, P = 0.005)

par(mar = c(5, 5, 2, 3), xpd = FALSE) #bottom, left, top, right (xpd=FALSE keeps abline inside plot area)
plot(area ~ max.wt, data = overall.hr, ylab = expression(paste('Home range area (km' ^'2', ')')), xlab = 'Body mass (kg)')
abline(m1)

## difference between males and females?
overall.hr.f <- overall.hr[overall.hr$sex == 'f',]
overall.hr.m <- overall.hr[overall.hr$sex == 'm',]

m2 <- lm(area ~ max.wt, data = overall.hr.f)
  summary(m2) ## no correlation btwn HR and body mass (r2 = 0.12, P = 0.325)
m3 <- lm(area ~ max.wt, data = overall.hr.m)
  summary(m3) ## strong correlation btwn HR and body mass (r2 = 0.94, P < 0.001)

par(mfrow = c(2,1))
plot(area ~ max.wt, data = overall.hr.f, ylab = expression(paste('Home range area (km' ^'2', ')')), xlab = 'Body mass (kg)',
     xlim = c(5.5, 11), ylim = c(0, 0.8))
  abline(m2)
  text(10.5, 0.1, expression(paste('r' ^'2', ' = 0.12')))
  text(5.5, 0.75, 'A', font = 2, cex = 1.3)
plot(area ~ max.wt, data = overall.hr.m, ylab = expression(paste('Home range area (km' ^'2', ')')), xlab = 'Body mass (kg)',
     xlim = c(5.5, 11), ylim = c(0, 0.8))
  abline(m3)
  text(10.5, 0.1, expression(paste('r' ^'2', ' = 0.94')))
  text(5.5, 0.75, 'B', font = 2, cex = 1.3)

## what about a correlation between HR and body mass for summer vs. winter?
## would make most sense to do this during breeding season (like Sweitzer 2003) but I don't have enough data
sum.hr.f <- hr.all[hr.all$sex == 'f' & hr.all$percent == 95 & hr.all$season == 'sum' & hr.all$method == 'kde',]
  sum.hr.f$max.wt <- max.wts[match(sum.hr.f$id, max.wts$i), 'max.i']
sum.hr.m <- hr.all[hr.all$sex == 'm' & hr.all$percent == 95 & hr.all$season == 'sum' & hr.all$method == 'kde',]
  sum.hr.m$max.wt <- max.wts[match(sum.hr.m$id, max.wts$i), 'max.i']

m4 <- lm(area ~ max.wt, data = sum.hr.f)
  summary(m4) ## no correlation btwn HR and body mass (r2 = 0.10)
m5 <- lm(area ~ max.wt, data = sum.hr.m)
  summary(m5) ## strong correlation btwn HR and body mass (r2 = 0.85, p = 0.001)
  
win.hr.f <- hr.all[hr.all$sex == 'f' & hr.all$percent == 95 & hr.all$season == 'win' & hr.all$method == 'kde',]
  win.hr.f$max.wt <- max.wts[match(win.hr.f$id, max.wts$i), 'max.i']
win.hr.m <- hr.all[hr.all$sex == 'm' & hr.all$percent == 95 & hr.all$season == 'win' & hr.all$method == 'kde',]
  win.hr.m$max.wt <- max.wts[match(win.hr.m$id, max.wts$i), 'max.i']
  
m6 <- lm(area ~ max.wt, data = win.hr.f)
  summary(m6) ## no correlation btwn HR and body mass (r2 = 0.03)
m7 <- lm(area ~ max.wt, data = win.hr.m)
  summary(m7) ## strong correlation btwn HR and body mass (r2 = 0.89, p = 0.016)
plot(m6)  

## add number of location points as a predictor to see whether model fit is improved
m8 <- lm(area ~ max.wt + n_locs, data = overall.hr)
  summary(m8)  ## r2 = 0.57, P = 0.027 for n_locs, P = 0.022 for max.wt (overall P = 0.002)

## and try separately for f/m
m9 <- lm(area ~ max.wt + n_locs, data = overall.hr.f)
  summary(m9)  ## r2 = 0.495, P = 0.057 for n_locs, P = 0.263 for max.wt (overall P = 0.09)
m10 <- lm(area ~ max.wt + n_locs, data = overall.hr.m)
  summary(m10) ## r2 = 0.943, P = 0.607 for n_locs, P < 0.001 for max.wt (overall P < 0.001)
   
# ---------------------------------------------------------------
## 12. Miscellaneous summary stats
# ---------------------------------------------------------------  

## 9/20/16 for discussion, compute % decrease in HR from summer to winter, ala Roze (2009):
(m.mcp <- 1 - (0.075 / 0.125)) ## males, 95% mcp, winter / summer
(f.mcp <- 1 - (0.063 / 0.232))
(a.mcp <- 1 - (0.069 / 0.185)) ## all

(m.kde <- 1 - (0.219 / 0.282))
(f.kde <- 1 - (0.229 / 0.363))
(a.kde <- 1 - (0.224 / 0.327))
