## Try weighted compositional analysis
## ala Millspaugh et al. 2006

# STEP 1: import data, incorporate GPS points, subset summer/winter (with >=5 locs per season),
#         and import veg data
# STEP 2: calculate UDs and 99% contours for each animal (overall/summer/winter) and create
#         overall outer contour boundary; clip UDs and store
# STEP 3: Create a list of tables with id, coord, and UD height for each animal
#         (at each each pixel)
# STEP 4: Assign values of covariates (veg categories) to cells
# STEP 5: Sum and divide the UD values per habitat type to get the "UD-weighted estimate of use"
# STEP 6: calculate availability data from veg polygons clipped to each animal's outer contour
# STEP 7-9: box plots, Wilk's lambda, etc.

#install.packages("ruf", repos="http://www.stat.ucla.edu/~handcock")
library(adehabitatHR)
library(googlesheets)
library(raster)
library(rgdal)
library(rgeos)
library(lattice)
library(rrcov)
library(ggplot2)
library(maptools)
library(dplyr)
library(sp)

######################
## 1. First, load porcupine location data & veg data
######################
gs_ls()
locs <- gs_title("Porc relocation data")
porc.vhf <- data.frame(gs_read(ss=locs, ws="Relocations", is.na(TRUE), range=cell_cols(c(1:8))))
colnames(porc.vhf) <- c("date", "id", "sess", "type", "time", "az", "utm_e", "utm_n")
porc.vhf <- subset(porc.vhf, type %in% c("V","V*","P","P*","L"))
porc.vhf$utm_e <- as.numeric(porc.vhf$utm_e)
porc.vhf$utm_n <- as.numeric(porc.vhf$utm_n)
## check date format before running line 51 or 52
porc.vhf$date <- as.Date(porc.vhf$date, "%m/%d/%Y") 
#porc.vhf$date <- as.Date(porc.vhf$date, origin = as.Date("1899-12-30"))

## Incorporate GPS data (1 random point per day)
porc.gps <- read.csv("daily.gps.csv") ## generated by 'gps_clean_IA.R'
porc.gps$type <- rep("gps", nrow(porc.gps))
porc.gps$az <- rep(NA, nrow(porc.gps))
porc.gps.df <- data.frame(porc.gps$Date, porc.gps$Animal.ID, porc.gps$Session, porc.gps$type,
                         porc.gps$Time, porc.gps$az, porc.gps$UTM.E, porc.gps$UTM.N)
colnames(porc.gps.df) <- colnames(porc.vhf)
porc.gps.df$date <- as.Date(porc.gps.df$date, "%m/%d/%Y")
porc.gps.df$id <- as.factor(porc.gps.df$id)

## combine VHF with GPS points
porc.locs <- rbind(porc.vhf, porc.gps.df)

## subset summer locations (before Nov 1 or after March 1) and winter (between Nov 1 and March 1)
sum.locs <- porc.locs[(porc.locs$date < "2015-11-01") | (porc.locs$date >= "2016-03-01"), ]
win.locs <- porc.locs[(porc.locs$date >= "2015-11-01") & (porc.locs$date < "2016-03-01"), ]

## can add seasons this way, but still need to subset because I don't want to remove ALL points from an 
## animal if it has <5 in only one season
#porc.locs$season[(porc.locs$date < "2015-11-01") | (porc.locs$date >= "2016-03-01")] <- 'summer'
#porc.locs$season[(porc.locs$date >= "2015-11-01") & (porc.locs$date < "2016-03-01")] <- 'winter'

## Keep only animals with >= 5 locations
n <- table(sum.locs$id)
sum.locs <- subset(sum.locs, id %in% names(n[n >= 5]), drop=TRUE)
sum.locs <- droplevels(sum.locs)

n <- table(win.locs$id)
win.locs <- subset(win.locs, id %in% names(n[n >= 5]), drop=TRUE)
win.locs <- droplevels(win.locs)

n <- table(porc.locs$id)
porc.locs <- subset(porc.locs, id %in% names(n[n >= 5]), drop=TRUE)
porc.locs <- droplevels(porc.locs)

## Load veg data
veg <- readOGR(dsn="shapefiles", layer="Veg categories CA", verbose=TRUE)
proj4string(veg) <- CRS("+proj=utm +zone=10 +datum=NAD83")
veg.ext <- readOGR(dsn="shapefiles", layer="Veg extent new", verbose=TRUE)
proj4string(veg.ext) <- proj4string(veg)

######################
## 2. Then, extract the UD from "adehabitatHR" package
###################### 

## Calculate grid & extent based on desired cell size (# meters on each side)
## For for each animal separately 

## Also calculate KUD based on summer points ONLY and winter points ONLY, but within 
## the grid of the extent for all of the points. Then clip to the 99% contour for all of 
## the points, as well as the veg layer extent.

ids <- unique(porc.locs$id)
kde.areas <- list()
kud.all <- list()
kern.i <- list()
outer_cont99 <- list()
contours99 <- list()
ud.third <- list()
ud.second <- list()

for (i in ids){
        locs.i <- porc.locs[porc.locs$id == i,]
        locs.i$id_season <- rep(paste(i, "_all", sep = ""), nrow(locs.i))
        locs.sum.i <- sum.locs[sum.locs$id == i,]
        locs.sum.i$id_season <- rep(paste(i, "_sum", sep = ""), nrow(locs.sum.i))
        locs.win.i <- win.locs[win.locs$id == i,]
        locs.win.i$id_season <- rep(paste(i, "_win", sep = ""), nrow(locs.win.i))
        locs.all.i <- rbind(locs.i, locs.sum.i, locs.win.i)
        sp.i <- SpatialPointsDataFrame(data.frame(locs.all.i$utm_e, locs.all.i$utm_n),
                                   data=data.frame(locs.all.i$id_season),
                                   proj4string=CRS("+proj=utm +zone=10 +datum=NAD83"))
        c = 10   ## desired cell size (meters)
        fake.kern <- kernelUD(xy = sp.i, extent = 1)
        spdf <- raster(as(fake.kern[[1]], "SpatialPixelsDataFrame"))
        eas <- diff(range(spdf@extent[1:2]))
        nor <- diff(range(spdf@extent[3:4]))
          if(eas > nor){
            g <- (eas/c)
          } else {
            g <- (nor/c)
          }
        
        # calculate UD on all IDs ("all," "summer," "winter") with same4all = TRUE
        kern.i <- kernelUD(xy = sp.i, h = 60, grid = g, extent = 1, same4all = TRUE)
        kde.i <- kernel.area(kern.i, percent = c(50, 90, 95, 99), unin = "m", unout = "km2", standardize = FALSE)
        data.frame(kde.i, row.names = c("50", "90", "95", "99"))
        kde.areas[[i]] <- kde.i
        kud.all[[i]] <- kern.i
        
        # make 99% contours (full, summer, winter)
        cont99 <- list()
        for (j in 1:length(kern.i)){
          cont99.i <- getverticeshr.estUD(kern.i[[j]], percent = 99, unin = "m", unout = "km2", standardize = FALSE)
          cont99[[j]] <- cont99.i
        }
        
        ## merge all 3 contours to make a single contour based on the outermost areas
        outer_cont99.i <- raster::union(cont99[[1]], cont99[[2]])
          if ((length(cont99)) > 2) {
              outer_cont99.i <- raster::union(outer_cont99.i, cont99[[3]]) ## because not all have winter
          }

        outer_cont99.i <- gUnaryUnion(outer_cont99.i) ## dissolve polygons but this gets rid of @data
        outer_cont99.i@polygons[[1]]@ID <- 'homerange' ## so it will match when creating SPDF below
        
        ## create data to make it a SPDF (necessary for steps later)
        row_data <- data.frame('homerange', (outer_cont99.i@polygons[[1]]@Polygons[[1]]@area))
        rownames(row_data) <- rep('homerange', nrow(row_data))
        colnames(row_data) <- c('id', 'area')
        outer_cont99.i <- SpatialPolygonsDataFrame(outer_cont99.i, data = row_data)
        
        ## store contours (access as follows: contours[[i]][[j]] where i = ID and j = 1:all, 2:sum, 3:win)
        outer_cont99[[i]] <- outer_cont99.i ## store
        contours99[[i]] <- cont99
      
        # clip summer & winter UD grids to the 99% outer contour and veg extent for 3rd order analysis
        third.ud.i <- list()
        for (j in 1:length(kern.i)){
            clipped.ud.i <- (kern.i[[j]])[outer_cont99.i,] ## outer boundary from ALL contours, see above
            clipped.ud.i <- clipped.ud.i[veg.ext,]
            third.ud.i[[j]] <- clipped.ud.i
        }
        ud.third[[i]] <- third.ud.i
        
        # clip summer & winter UD grids to just the veg extent ('study area') for 2nd order analysis
        second.ud.i <- list()
        for (j in 1:length(kern.i)){
            clipped.ud.i <- (kern.i[[j]])[veg.ext,]
            second.ud.i[[j]] <- clipped.ud.i
        }
        ud.second[[i]] <- second.ud.i
} 

## it's cool to look at a few here:
image(ud.third[[17]][[1]]) #first brackets are animal ID, second are season (1:all, 2:sum, 3:win)
plot(veg, add=TRUE)
plot(contours99[[17]][[1]], add=TRUE, border='black', lwd=2)
plot(contours99[[17]][[2]], add=TRUE, border='green', lwd=2) #summer
plot(contours99[[17]][[3]], add=TRUE, border='blue', lwd=2) #winter
plot(outer_cont99[[17]], add = TRUE, border = 'gray', lwd=2)

## combine this with porc_homerange.R file? or use this output for that analysis, at least
## output KDE areas
#write.csv(kde.areas, "csvs/kde_areas_w-gps_050916.csv")

######################
## 3. Then, create a list of tables with id, coord, and UD height for each porc
##    - For UD height at each pixel (grid cell)
######################

## 3rd ORDER: CLIPPED SEASONAL UDS / 99% CONTOURS
ids <- unique(porc.locs$id)
heights.list <- list()

for(i in ids){
  heights.i <- list()
      for(j in 1:length(ud.third[[i]])){
        ud.i <- ud.third[[i]][[j]]
        ud.height.i <- ud.i$ud
        coords.i <- ud.i@coords
        ht.coords.i <- data.frame((rep(i, length(ud.height.i))), ud.height.i, coords.i)
        colnames(ht.coords.i) <- c("id", "height", "x", "y")
        heights.i[[j]] <- data.frame(ht.coords.i) 
      }
  heights.list[[i]] <- heights.i 
}

## wireframe plots! better function to get lat/lon or put it on a map?
wireframe(height ~ x * y, data = heights.list[[17]][[1]], drape=TRUE, main="15.17 overall UD height")
## nice! again, first brackets are animal ID, second are season (1:all, 2:sum, 3:win)

## 2nd ORDER: ORIGINAL SEASONAL UDS / ENTIRE STUDY AREA
ids <- unique(porc.locs$id)
second.heights.list <- list()

for(i in ids){
  second.heights.i <- list()
  for(j in 1:length(ud.second[[i]])){
    ud.i <- ud.second[[i]][[j]]
    ud.height.i <- ud.i$ud
    coords.i <- ud.i@coords
    ht.coords.i <- data.frame((rep(i, length(ud.height.i))), ud.height.i, coords.i)
    colnames(ht.coords.i) <- c("id", "height", "x", "y")
    second.heights.i[[j]] <- data.frame(ht.coords.i) 
  }
  second.heights.list[[i]] <- second.heights.i 
}

## wireframe plots! better function to get lat/lon or put it on a map?
wireframe(height ~ x * y, data = second.heights.list[[16]][[1]], drape=TRUE, main="15.17 overall UD height")
## nice! again, first brackets are animal ID, second are season (1:all, 2:sum, 3:win)

######################
## 4. Assign values of covariates (veg class, canopy height) to cells
######################

## 3rd ORDER: ORIGINAL SEASONAL UDS / 99% CONTOURS
ids <- unique(porc.locs$id)
final.list <- list()

for (i in ids){
  final.i <- list()
        for(j in 1:length(heights.list[[i]])){
          ht.i <- heights.list[[i]][[j]]
          spdf.i <- SpatialPointsDataFrame(data.frame(ht.i$x, ht.i$y),
                                           data=data.frame(ht.i$id, ht.i$height),
                                           proj4string = CRS(proj4string(veg)))
          spdf.i@data$veg <- over(spdf.i, veg)$Class_4
          df.i <- data.frame(i, spdf.i@data$ht.i.height, spdf.i@coords, spdf.i@data$veg)
          colnames(df.i) <- c("id", "ud", "x", "y", "veg")
          df.i <- df.i[!is.na(df.i$veg),]
          final.i[[j]] <- df.i
        }
  final.list[[i]] <- final.i
}

## another cool figure:
plot(spdf.i)
plot(veg, add=TRUE)
#plot(contours99[[17]][[2]], add=TRUE, border="blue", lwd=2)
plot(outer_cont99[[17]], add = TRUE, border = 'blue', lwd = 2)
points(utm_n ~ utm_e, data=porc.locs[porc.locs$id == "16.18",], col="red", pch=16)
points(utm_n ~ utm_e, data=sum.locs[sum.locs$id == "16.18",], col="green", pch=16)
points(utm_n ~ utm_e, data=win.locs[win.locs$id == "16.18",], col="blue", pch=16)

## 2nd ORDER: ORIGINAL SEASONAL UDS / ENTIRE STUDY AREA
ids <- unique(porc.locs$id)
second.final.list <- list()

for (i in ids){
  final.i <- list()
  for(j in 1:length(second.heights.list[[i]])){
    ht.i <- second.heights.list[[i]][[j]]
    spdf.i <- SpatialPointsDataFrame(data.frame(ht.i$x, ht.i$y),
                                     data=data.frame(ht.i$id, ht.i$height),
                                     proj4string = CRS(proj4string(veg)))
    spdf.i@data$veg <- over(spdf.i, veg)$Class_4
    df.i <- data.frame(i, spdf.i@data$ht.i.height, spdf.i@coords, spdf.i@data$veg)
    colnames(df.i) <- c("id", "ud", "x", "y", "veg")
    df.i <- df.i[!is.na(df.i$veg),]
    final.i[[j]] <- df.i
  }
  second.final.list[[i]] <- final.i
}

## another cool figure:
plot(spdf.i) ## or store the SPDFs a
plot(veg, add=TRUE)
#plot(contours99[[17]][[2]], add=TRUE, border="blue", lwd=2)
plot(outer_cont99[[17]], add = TRUE, border = 'blue', lwd = 2)
points(utm_n ~ utm_e, data=porc.locs[porc.locs$id == "16.18",], col="red", pch=16)
points(utm_n ~ utm_e, data=sum.locs[sum.locs$id == "16.18",], col="green", pch=16)
points(utm_n ~ utm_e, data=win.locs[win.locs$id == "16.18",], col="blue", pch=16)

######################
## 5. For weighted compositional analysis: 
## sum raw UD values by veg type and divide the summed UD values by the 
## total UD value of all patches to obtain a "UD-weighted estimate of use 
## for each habitat type for each individual animal" 
## - (Millspaugh et al. 2004 p. 391)
######################

## need to reclassify "0" use values because log(0) = -Inf, which means that veg category
## will be excluded. Eads et al. 2012 use 0.30, "the minimum value that reduced type I error
## rates in simulation studies (see Bingham et al. 2007)." I'll use 1e-10...
## ** do it for the sum or as the raw use? check out that paper and do error sensitivity **
## example: for 15.02, if I change raw UD=0 to 1e-10, the log_ud_weights are meadow = -12, 
## pasture = -12, shrub swale = -13, and wooded swale = -13.
## but when I change ud sum (after "aggregate") from 0 to 1e-10, the weights are all -18.4
## I'll do it the second way for now (change summed UD for each category to 1e-10 if it's 0)

## I don't think there end up being any -Inf in the summer data anyway

######### THIRD ORDER
ids <- unique(porc.locs$id)
third.tables <- list()

for (i in ids){
  tables.i <- list()
      for (j in 1:length(final.list[[i]])){
          ud.i <- final.list[[i]][[j]]
          table.i <- aggregate(ud ~ veg, data = ud.i, FUN = sum) #if error, make sure there's no object 'sum' (rm(sum))
          table.i$ud[table.i$ud == 0] <- 1e-10 #do this here or before "aggregate"?
          table.i$ud_weight <- table.i$ud / sum(table.i$ud)
          table.i$log_ud_weight <- log(table.i$ud_weight)
          tables.i[[j]] <- table.i
      }
  third.tables[[i]] <- tables.i
}

######### SECOND ORDER
ids <- unique(porc.locs$id)
second.tables <- list()

for (i in ids){
  tables.i <- list()
      for (j in 1:length(second.final.list[[i]])){
          ud.i <- second.final.list[[i]][[j]]
          table.i <- aggregate(ud ~ veg, data = ud.i, FUN = sum) #if error, make sure there's no object 'sum' (rm(sum))
          table.i$ud[table.i$ud == 0] <- 1e-10 #do this here or before "aggregate"?
          table.i$ud_weight <- table.i$ud / sum(table.i$ud)
          table.i$log_ud_weight <- log(table.i$ud_weight)
          tables.i[[j]] <- table.i
  }
  second.tables[[i]] <- tables.i
}

######################
## 6. Now, calcluate "log-transformed availability data"
### CLIP POLYGONS Stolen from: https://philmikejones.wordpress.com/2015/09/01/clipping-polygons-in-r
### because "intersect" excludes some edge polygons and "gIntersection" doesn't retain polygon ids
######################

####### THIRD ORDER (WITHIN 99% OUTER CONTOURS)
ids <- unique(porc.locs$id)
veg.99kdes <- list()
veg.tables <- list()

for (i in ids){
    cont99.i <- outer_cont99[[i]]
    clip.i <- gIntersection(cont99.i, veg, byid = T) #this is just a SpatialPolygons (no data)
    row.names(clip.i) <- gsub("homerange ", "", row.names(clip.i))    
    keep <- row.names(clip.i)
    clip.i <- spChFIDs(clip.i, keep) #changes feature IDs in the SP
    clip.data <- as.data.frame(veg@data[keep,]) #this is what we'll add as @data to the SPDF
    clip.spdf <- SpatialPolygonsDataFrame(clip.i, clip.data)  #this is fixed!
    clip.spdf <- clip.spdf[!is.na(clip.spdf@data$Class_4),] #get rid of NAs
    area.all <- gArea(clip.spdf, byid = TRUE) #units should be m^2
    veg.df.i <- data.frame(clip.spdf$Class_4, area.all)
    colnames(veg.df.i) <- c("veg", "area")
    veg.areas.i <- aggregate(area ~ veg, data=veg.df.i, FUN = sum)
    veg.areas.i$prop_area <- veg.areas.i$area / sum(veg.areas.i$area)
    veg.areas.i$log_avail <- log(veg.areas.i$prop_area)
    veg.99kdes[[i]] <- clip.spdf
    veg.tables[[i]] <- veg.areas.i
}

## good, no self-intersection errors!
## any missing polygons at edges?
plot(veg.99kdes[[17]]) #all look great!
plot(contours99[[17]][[1]], add = TRUE, border = 'black', lwd = 2)
plot(contours99[[17]][[2]], add = TRUE, border = 'green', lwd = 2)
plot(contours99[[17]][[3]], add = TRUE, border = 'blue', lwd = 2)
plot(outer_cont99[[17]], add = TRUE, border = 'red', lwd = 2, lty = 2)


####### SECOND ORDER: WITHIN ENTIRE STUDY AREA
####### (will be the same for all animals)

## columns: veg, area, prop_area, log_avail
area.veg <- gArea(veg, byid = TRUE) ## calculates areas of all the polygons (in m^2?)
veg.df <- data.frame(veg$Class_4, area.veg)
colnames(veg.df) <- c('veg', 'area')
total.veg.areas <- aggregate(area ~ veg, data = veg.df, FUN = sum) ## sum areas by veg type
total.veg.areas$prop_area <- total.veg.areas$area / sum(total.veg.areas$area)
total.veg.areas$log_avail <- log(total.veg.areas$prop_area)
head(total.veg.areas)

######################
## 7. Subtract differences in log-transformed availability data from the
##    log-transformed use data for each animal
######################

## combine used and avail in the same table

######## THIRD ORDER SELECTION: 'third.tables' (list of used data) & 'veg.tables' (list of avail. data)
ids <- unique(porc.locs$id)
final.tables <- NULL

for (i in ids){
  final.table.i <- NULL
    for (j in 1:length(third.tables[[i]])){
      tables.j <- third.tables[[i]][[j]] ## proportional use based on season-specific UD
      veg.tables.j <- veg.tables[[i]] ## proportional avail. within OUTER contour
      tables.j$log_avail <- veg.tables.j$log_avail
      tables.j$id <- rep(i, nrow(tables.j))
      tables.j$sel <- tables.j$log_ud_weight - tables.j$log_avail ## 'sel' = log-ratio differences
      tables.j$season <- rep(j, nrow(tables.j))
      final.df.j <- data.frame(tables.j$id, tables.j$season, tables.j$veg, 
                               tables.j$log_ud_weight, tables.j$log_avail, tables.j$sel)
      colnames(final.df.j) <- c('id', 'season', 'veg', 'log_ud_wt', 'log_avail', 'sel')
      final.table.i <- bind_rows(final.table.i, final.df.j)
    }
  final.tables <- bind_rows(final.tables, final.table.i)
}
## the 'unequal factor levels' error is OK

overall.sel <- final.tables[final.tables$season == 1,]
summer.sel <- final.tables[final.tables$season == 2,]
winter.sel <- final.tables[final.tables$season == 3,]

write.csv(overall.sel, 'csvs/overall_wt_comp_analysis_072616.csv')
write.csv(summer.sel, 'csvs/summer_wt_comp_analysis_072616.csv')
write.csv(winter.sel, 'csvs/winter_wt_comp_analysis_072616.csv')


######## SECOND ORDER SELECTION: 'second.tables' (list of used data) & 'total.veg.areas' (avail. data)
ids <- unique(porc.locs$id)
final.tables.second <- NULL

for (i in ids){
        final.table.i <- NULL
      for (j in 1:length(second.tables[[i]])){
        table.j <- total.veg.areas[,c(1, 4)] ## start with all veg type avail. and add use below
        second.tables.i <- second.tables[[i]][[j]] ## proportional use based on season-specific UD
        table.j$log_ud_wt <- second.tables.i[match(table.j$veg, second.tables.i$veg), 'log_ud_weight']
        table.j[is.na(table.j)] <- 0
        table.j$id <- rep(i, nrow(table.j))
        table.j$sel <- table.j$log_ud_wt - table.j$log_avail ## log-ratio differences
        table.j$season <- rep(j, nrow(table.j))
        table.j <- table.j[,c('id', 'season', 'veg', 'log_ud_wt', 'log_avail', 'sel')]
        final.table.i <- bind_rows(final.table.i, table.j)
  }
    final.tables.second <- bind_rows(final.tables.second, final.table.i)
}

overall.sel.2 <- final.tables.second[final.tables.second$season == 1,]
summer.sel.2 <- final.tables.second[final.tables.second$season == 2,]
winter.sel.2 <- final.tables.second[final.tables.second$season == 3,]

write.csv(overall.sel.2, 'csvs/overall_wca_second_080516.csv')
write.csv(summer.sel.2, 'csvs/summer_wca_second_080516.csv')
write.csv(winter.sel.2, 'csvs/winter_wca_second_080516.csv')

######################
## 7. Compute Wilk's lambda to test for overall selection
######################

## function "manova" or "Wilks.test"? the latter is in package "rrcov"
## "groups" are veg, and we are testing for differences between "log_ud_wt" and "log_avail"

groups <- as.factor(summer.sel$veg)
x <- as.matrix(summer.sel[,4:5])

## can do method "c" for mean and variance or "rank" for wilks lambda ranks
## am I doing this right? should I just do MANOVA on the ranking table (below)?
wilks.summer <- Wilks.test(x, grouping = groups, method="rank")
wilks.summer

############## 
### SECOND ORDER

groups <- as.factor(winter.sel.2$veg)
x <- as.matrix(winter.sel.2[,4:5])
wilks.winter.2 <- Wilks.test(x, grouping = groups, method = 'rank')
wilks.winter.2

######################
## 8. If use differs significantly from availability (p-value for Wilks lambda):
##    calculate the mean and st. dev. for the log-ratio differences, and use these to rank each habitat type
## - Then, use t-tests "to assess difference between ranks and to determine where 
##   selection differed by habitat pairs (Aebischer et al. 1993, Erickson et al. 2001)" - Millspaugh et al. 2006, p. 392
## - I'm actually ranking the way Erickson et al. (2001) describe, by subtracting selection ratio of a 
##    reference category from each veg type in a matrix; not sure how Millspaugh et al. ranked based on means
######################

#### RANKING ALA AEBISCHER ET AL. 1993 (better described in Erickson et al. 2001)
## ** what to do with NA values? **

## make matrices for each season
season_matrices <- list()
for (i in 1:3){
      sel_i <- data.frame(final.tables$id[final.tables$season == i], final.tables$veg[final.tables$season == i], final.tables$sel[final.tables$season == i])
      colnames(sel_i) <- c('id', 'veg', 'sel')
      matrix_i <- reshape(data = sel_i, direction = 'wide', v.names = 'sel', idvar = 'id', timevar = 'veg', sep = '_')
      names(matrix_i) <- gsub('sel_', '', names(matrix_i)) ## get rid of 'sel' in column names
      season_matrices[[i]] <- matrix_i
}

## calculate differences in log ratio in relation to reference category
ref <- 5    # this is the column for 'conifer forest' (my reference category); can change it here
d_matrices <- list()
d_means <- list()

for (i in 1:3){
      season <- season_matrices[[i]]
      d_ref <- season[,2:10] - season[,ref] ## subtract the column of the reference category
      d_ref_df <- data.frame(season$id, d_ref)
      names(d_ref_df) <- gsub('[.]', ' ', names(d_ref_df))
      d_matrices[[i]] <- d_ref_df ##store (will use for t-tests)
      d_means_i <- colMeans(d_ref_df[,2:10], na.rm = TRUE) ## is it OK to ignore NAs?
      d_means_df <- stack(d_means_i)
      colnames(d_means_df) <- c('d', 'veg')   
      d_means_df$rank <- rank(-d_means_df$d) ## negative sign so it ranks largest -> smallest
      d_means[[i]] <- d_means_df ##store
}

d_means ## here are the ranks!
## summer most closely resembles 'all'

## now do t-tests using the log-differences in each veg column in d_matrices
pairwise_ttests <- list()
for (i in 1:3){
      season <- d_matrices[[i]][,-5] ## remove reference category
    # first test between each category and the reference  
      pairwise_j <- NULL
    for (j in 2:9){
        ttest_j <- t.test(season[,j], mu = 0) ## 1-sample t-test against reference category
        ttest_j_df <- data.frame(j, 0, ttest_j$estimate, ttest_j$conf.int[1], ttest_j$conf.int[2], ttest_j$p.value) ## 0 stands for reference category ('veg type 0')
        colnames(ttest_j_df) <- c('v1', 'v2', 'mean_diff', 'lci_95', 'uci_95', 'p')  
        pairwise_j <- bind_rows(pairwise_j, ttest_j_df) ## store
    # then test pairwise between all categories 
      pairwise_k  <- NULL
      for (k in 2:9){
        ttest_k <- t.test(season[,j], season[,k], paired = TRUE)
        ttest_k_df <- data.frame(j, k, ttest_k$estimate, ttest_k$conf.int[1], ttest_k$conf.int[2], ttest_k$p.value)
        colnames(ttest_k_df) <- c('v1', 'v2', 'mean_diff', 'lci_95', 'uci_95', 'p')
        pairwise_k <- bind_rows(pairwise_k, ttest_k_df) ## store
      }
    pairwise_j <- bind_rows(pairwise_j, pairwise_k)
    veg_key <- data.frame((names(season)[2:9]), 2:9)
    colnames(veg_key) <- c('veg', 'veg_id')
    ref_key <- data.frame('veg' = 'conifer forest', 'veg_id' = 0) ## can modify reference category label
    veg_key <- rbind(veg_key, ref_key)
    pairwise_j$veg1 <- veg_key[match(pairwise_j$v1, veg_key$veg_id), 'veg'] 
    pairwise_j$veg2 <- veg_key[match(pairwise_j$v2, veg_key$veg_id), 'veg']
    }      
  pairwise_ttests[[i]] <- pairwise_j
}

## output as .csvs to make tables fo ms/appendix
write.csv(pairwise_ttests[[2]], 'csvs/pairwise_ttests_summer.csv')
write.csv(pairwise_ttests[[3]], 'csvs/pairwise_ttests_winter.csv')

## pull out the significant pairs now for interpretation
pairwise_overall <- pairwise_ttests[[1]]
sig_overall <- pairwise_overall[pairwise_overall$p <= 0.05,]
sig_overall <- sig_overall[!is.na(sig_overall$veg1),]

pairwise_summer <- pairwise_ttests[[2]]
sig_summer <- pairwise_summer[pairwise_summer$p <= 0.05,]
sig_summer <- sig_summer[!is.na(sig_summer$veg1),]

pairwise_winter <- pairwise_ttests[[3]]
sig_winter <- pairwise_winter[pairwise_winter$p <= 0.05,]
sig_winter <- sig_winter[!is.na(sig_winter$veg1),]

##########################################################################
## Boxplots:

require(reshape2)

## reshape/melt matrices and assign colors to veg classes for plotting:
veg_class <- c('beach', 'beachgrass.dune', 'coastal.scrub', 'conifer.forest', 'fruit.tree', 'marsh', 'meadow', 'pasture', 'swale')
veg_colors <- c("khaki1", "khaki3", "khaki4", "darkolivegreen4", "coral1", "aquamarine", "yellow3", "darkolivegreen3", "darkseagreen3")
colors <- data.frame(veg_class, veg_colors)
colors$veg_colors <- as.character(colors$veg_colors)

summer_melt <- melt(d_matrices[[2]])
colnames(summer_melt) <- c('id', 'veg', 'd')
summer_melt$season <- rep('sum', nrow(summer_melt))
summer_melt$rank <- d_means[[2]][match(summer_melt$veg, d_means[[2]]$veg), 3] ## where 3 is the 'rank' column in d_means[[2]]

winter_melt <- melt(d_matrices[[3]])
colnames(winter_melt) <- c('id', 'veg', 'd')
winter_melt$season <- rep('win', nrow(winter_melt))
winter_melt$rank <- d_means[[3]][match(winter_melt$veg, d_means[[3]]$veg), 3]

## This plot is similar to Figure 5 in Millspaugh et al. 2006
## - do I want horizontal or vertical? add '+ coord_flip()' 
## - 'guide = FALSE' in scale_fill_manual turns off the legend (since I have axis labels)
s <- ggplot(data = summer_melt, aes(x = reorder(veg, rank), y = d, fill = as.factor(veg))) +
        geom_boxplot() + geom_point(position = position_dodge(0.8), size = 2) +
        scale_fill_manual(values = colors$veg_colors, guide = FALSE) +
        geom_hline(yintercept = 0, linetype = 'dashed') + ylim(-5, 5) + #or (-15, 5) like winter?
        xlab('Vegetation Type') + ylab('Differences in Log Ratio') +
      theme(axis.text.x = element_text(size = 12, colour = 'black', angle = 35, hjust = 1),
            axis.text.y = element_text(size = 12, colour = 'black'),
            axis.title = element_text(size = 12, colour = 'black'),
            axis.line.x = element_line(size = 0.5, colour = 'black'),
            axis.line.y = element_line(size = 0.5, colour = 'black'),
            panel.background = element_rect(fill = 'white')) +
      geom_text(label ='*', aes(x = 1, y = -5), size = 8, colour = 'grey50') +
      geom_text(label ='*', aes(x = 2, y = -5), size = 8, colour = 'grey50') +
      geom_text(label ='*', aes(x = 3, y = -5), size = 8, colour = 'grey50')
s #summer (warning message is OK; it's because of the NAs)

w <- ggplot(data = winter_melt, aes(x = reorder(veg, rank), y = d, fill = as.factor(veg))) +
        geom_boxplot() + geom_point(position = position_dodge(0.8), size = 2) +
        scale_fill_manual(values = colors$veg_color, guide = FALSE) +
        geom_hline(yintercept = 0, linetype = 'dashed') + ylim(-15.0, 5.0) +
        xlab('Vegetation Type') + ylab('Differences in Log Ratio') +
      theme(axis.text.x = element_text(size = 12, colour = 'black', angle = 35, hjust = 1),
            axis.text.y = element_text(size = 12, colour = 'black'),
            axis.title = element_text(size = 12, colour = 'black'),
            axis.line.x = element_line(size = 0.5, colour = 'black'),
            axis.line.y = element_line(size = 0.5, colour = 'black'),
            panel.background = element_rect(fill = 'white')) +
      geom_text(label ='*', aes(x = 1, y = -15), size = 8, colour = 'grey50') +
      geom_text(label ='*', aes(x = 9, y = -15), size = 8, colour = 'grey50')
w #winter (warning message is OK; it's because of the NAs)

##########################################################################
## Simple / old ranking method. (Is this wrong? It sounds like what Marzluff et al. 2006 are describing, 
## instead of the ranking process in Erickson et al. 2001, above.)

## calculate mean and sd of "sel" for each habitat type, across individuals
veg_types <- unique(final.tables$veg)
means_tables <- list()

for (i in 1:3){
  means_table_i <- NULL
    for (j in veg_types) {
      season <- final.tables[final.tables$season == i,]
      veg.j <- season[season$veg == j,]
      mean.sel.j <- mean(veg.j$sel)
      sd.sel.j <- sd(veg.j$sel)
      se.sel.j <- (sd.sel.j)/sqrt(nrow(veg.j))
      table.j <- data.frame(i, j, mean.sel.j, sd.sel.j, se.sel.j)
      colnames(table.j) <- c("season", "veg", "mean", "sdev", "se")  
      means_table_i <- rbind(means_table_i, table.j)
  }
  means_tables[[i]] <- means_table_i
}

## assign colors to each veg class for plotting
## order follows unique(means_table[[1]]$veg: beach, beachgrass dune, coastal scrub, conifer forest, fruit tree, marsh, meadow, pasture, swale
veg_colors <- c("khaki1", "khaki3", "khaki4", "darkolivegreen4", "coral1", "aquamarine", "yellow3", "darkolivegreen3", "darkseagreen3")

## and add colors to means_tables
means_tables[[1]]$veg_color <- veg_colors
means_tables[[2]]$veg_color <- veg_colors
means_tables[[3]]$veg_color <- veg_colors

## rank veg types:
dodge <- position_dodge(width = 0.9)
limits <- aes(ymax = means_tables[[2]]$mean + means_tables[[2]]$se,
              ymin = means_tables[[2]]$mean - means_tables[[2]]$se)

p <- ggplot(data = means_tables[[2]], aes(x = reorder(veg, mean), y = mean)) +
      geom_bar(stat = "identity", position = dodge, aes(fill = as.factor(veg))) +
      geom_errorbar(limits, position = dodge, width = 0.25) +
      scale_fill_manual(values = means_tables[[2]]$veg_color, guide = FALSE) +
      xlab('Vegetation type') + ylab("Mean log-ratio differences (+/- SE)") +
    theme(axis.text.x = element_text(size = 12, colour = 'black', angle = 45, hjust = 1),
          axis.text.y = element_text(size = 12, colour = 'black'),
          axis.title = element_text(size = 14, colour = 'black'),
          axis.line.x = element_line(size = 1, colour = 'black'),
          axis.line.y = element_line(size = 1, colour = 'black'),
          panel.background = element_rect(fill = 'white'),
          axis.ticks.x = element_line(size = 1, colour = 'black'))
p
## 'guide = FALSE' turns off the legend, since veg categorie are labeled on


############ SECOND ORDER (OLD METHOD)
## calculate mean and sd of "sel" for each habitat type, across individuals
veg_types <- unique(final.tables.second$veg)
means_tables_second <- list()

for (i in 1:3){
    means_table_i <- NULL
  for (j in veg_types) {
      season <- final.tables.second[final.tables.second$season == i,]
      veg.j <- season[season$veg == j,]
      mean.sel.j <- mean(veg.j$sel)
      sd.sel.j <- sd(veg.j$sel)
      se.sel.j <- (sd.sel.j)/sqrt(nrow(veg.j))
      table.j <- data.frame(i, j, mean.sel.j, sd.sel.j, se.sel.j)
      colnames(table.j) <- c("season", "veg", "mean", "sdev", "se")  
      means_table_i <- rbind(means_table_i, table.j)
  }
  means_tables_second[[i]] <- means_table_i
}

## assign colors to each veg class for plotting
## order follows unique(means_table[[1]]$veg: beach, beachgrass dune, coastal scrub, conifer forest, fruit tree, marsh, meadow, pasture, swale
veg_colors <- c("khaki1", "khaki3", "khaki4", "darkolivegreen4", "coral1", "aquamarine", "yellow3", "darkolivegreen3", "darkseagreen3")

## and add colors to means_tables
means_tables_second[[1]]$veg_color <- veg_colors
means_tables_second[[2]]$veg_color <- veg_colors
means_tables_second[[3]]$veg_color <- veg_colors

## rank veg types:
dodge <- position_dodge(width = 0.9)
limits <- aes(ymax = means_tables_second[[3]]$mean + means_tables_second[[3]]$se,
              ymin = means_tables_second[[3]]$mean - means_tables_second[[3]]$se)

p2 <- ggplot(data = means_tables_second[[3]], aes(x = reorder(veg, mean), y = mean)) +
        geom_bar(stat = "identity", position = dodge, aes(fill = as.factor(veg))) +
        geom_errorbar(limits, position = dodge, width = 0.25) +
        scale_fill_manual(values = means_tables_second[[3]]$veg_color, guide = FALSE) +
        xlab('Vegetation type') + ylab("Mean log-ratio differences (+/- SE)") +
      theme(axis.text.x = element_text(size = 12, colour = 'black', angle = 45, hjust = 1),
            axis.text.y = element_text(size = 12, colour = 'black'),
            axis.title = element_text(size = 14, colour = 'black'),
            axis.line.x = element_line(size = 1, colour = 'black'),
            axis.line.y = element_line(size = 1, colour = 'black'),
            panel.background = element_rect(fill = 'white'),
            axis.ticks.x = element_line(size = 1, colour = 'black'))
p2
## 'guide = FALSE' turns off the legend, since veg categorie are labeled on


######################
## Old box plots (raw selection ratios, not difference in means compared to a reference category)

par(mar=c(5, 9, 3, 3), xpd=FALSE)
boxplot(sel ~ veg, data = winter.sel, xaxt="n", las=2, horizontal=TRUE, outline=T)
axis(1)
title(xlab = "Differences in log ratio", line=3)
abline(v=0, lty = 1, col="red")

## **THIS IS THE OLD WAY... SEE BELOW

sel_means_summer <- aggregate(sel ~ veg, data = summer.sel, FUN = mean)
sel_means_summer$season <- rep('2', nrow(sel_means_summer))
colnames(sel_means_summer) <- c('veg', 'sel_means', 'season')

sel_means_winter <- aggregate(sel ~ veg, data = winter.sel, FUN = mean)
sel_means_winter$season <- rep('3', nrow(sel_means_winter))
colnames(sel_means_winter) <- c('veg', 'sel_means', 'season')

sel_means <- rbind(sel_means_summer, sel_means_winter)
sel_means$season <- as.factor(sel_means$season)

x <- ggplot(final.tables[final.tables$season != '1',], aes(x = veg, y = sel, color = as.factor(season))) +
  geom_boxplot(position = position_dodge(0.8)) + geom_point(position = position_dodge(0.8), size = 3)  + 
  scale_colour_manual(values = c('black', 'darkgray')) + coord_flip() + geom_hline(yintercept = 0) + 
  xlab('Vegetation type') + ylab('Difference in selection ratio') +
  theme(axis.text = element_text(size = 12, colour = 'black'),
        axis.title = element_text(size = 14, colour = 'black'),
        axis.line.x = element_line(size = 1, colour = 'black'),
        axis.line.y = element_line(size = 1, colour = 'black'),
        panel.background = element_rect(fill = 'white'),
        legend.background = element_rect(colour = 'white'),
        legend.key = element_rect(fill = 'white'),
        legend.text = element_text(size = 12),
        legend.key.size = unit(1, 'cm')) +
  scale_shape_manual("",
                     breaks = c('Summer', 'Winter'),
                     values = c(0, 0))
x

######################
######################
## cool figures but this is really messy (fix later):
ids <- unique(sum.locs$id)
for (i in ids){
  veg.i <- veg.99kdes[[i]][[2]]
  mypath <- file.path("figures", "kdes_with_veg", paste(i, "_veg_99kde", ".png", sep = ""))
  png(file=mypath)
  mytitle = paste("99% KDE ", i, sep = "")
  par(mar=c(2.1, 3.1, 3.1, 3.1), xpd=TRUE)
  plot(veg.i, main = mytitle)
  leg.txt <- sort(unique(veg$Class_2))
  leg.col <- c("khaki1", "khaki3", "aquamarine", "khaki4", "darkolivegreen4", "cadetblue1",
               "coral1", "yellow3", "darkolivegreen3", "darkseagreen3", "aquamarine4")
  legend("topright", inset=c(-0.3,0), legend = leg.txt, pch = 15, col = leg.col, cex=1.2)
  plot(veg.i[veg.i$Class_2 == "Beach",], add=TRUE, col="khaki1")
  plot(veg.i[veg.i$Class_2 == "Beachgrass dune",], add=TRUE, col="khaki3")
  plot(veg.i[veg.i$Class_2 == "Brackish marsh",], add=TRUE, col="aquamarine")
  plot(veg.i[veg.i$Class_2 == "Coastal scrub",], add=TRUE, col="khaki4")
  plot(veg.i[veg.i$Class_2 == "Conifer forest",], add=TRUE, col="darkolivegreen4")
  plot(veg.i[veg.i$Class_2 == "Freshwater marsh",], add=TRUE, col="cadetblue1")
  plot(veg.i[veg.i$Class_2 == "Fruit tree",], add=TRUE, col="coral1")
  plot(veg.i[veg.i$Class_2 == "Meadow",], add=TRUE, col="yellow3")
  plot(veg.i[veg.i$Class_2 == "Pasture",], add=TRUE, col="darkolivegreen3")
  plot(veg.i[veg.i$Class_2 == "Shrub swale",], add=TRUE, col="darkseagreen3")
  plot(veg.i[veg.i$Class_2 == "Wooded swale",], add=TRUE, col="aquamarine4")
  plot(porc.sp[porc.sp$porc.locs.id == i,], add=TRUE, pch=16, cex=1.5, col="black")
  plot(sum.sp[sum.sp$sum.locs.id == i,], add=TRUE, pch=16, cex=1.5, col="red")
  legend("bottomright", inset=c(-0.3,0), legend = c("Summer points", "Winter points"), pch=16, col=c("red", "black"), cex=1.2)
  scalebar(500, xy=click(), type='bar', divs=4, below = "meters")
  dev.off() 
}

## may need to run this again to be able to plot again:
#dev.off()

## quick and dirty home range plot:

ids.m <- c("15.03", "15.04", "15.06", "15.11", "15.14", "16.15", "16.18")
ids.f <- c("15.01", "15.02", "15.05", "15.07", "15.08", "15.09", "15.10", "15.12", "15.13", "16.16", "16.17")
ids.m <- c(3, 4, 6, 11, 14, 15, 17)
ids.f <- c(2, 5, 7, 8, 9, 10, 12, 13, 16)

plot(veg.ext, lwd = 2)
for (i in ids.m){
  plot(contour.list[[i]], add=TRUE, col='gray')
}

for (j in ids.f){
  plot(contour.list[[1]], add=TRUE, density = 20)
}

plot(veg.ext, lwd = 2)
legend("right", inset=c(0.1,0), legend = c("Female", "Male"), fill = c('gray', 'black'), 
       density = c(NA, 20), cex=1.2, title = "99% KDEs")
scalebar(1000, xy=click(), type='bar', divs=2, below = "m")

## females
plot(contour.list[[2]], add=TRUE, col='gray')
plot(contour.list[[12]], add=TRUE, col='gray')
plot(contour.list[[13]], add=TRUE, col='gray')
plot(contour.list[[16]], add=TRUE, col='gray')
plot(contour.list[[7]], add=TRUE, col='gray')
plot(contour.list[[9]], add=TRUE, col='gray')
plot(contour.list[[10]], add=TRUE, col='gray')
plot(contour.list[[8]], add=TRUE, col='gray')
plot(contour.list[[5]], add=TRUE, col='gray')
plot(contour.list[[1]], add=TRUE, col='gray')

## males
plot(contour.list[[3]], add=TRUE, density = 20)
#plot(contour.list[[4]], add=TRUE, density = 20)
plot(contour.list[[6]], add=TRUE, density = 20)
plot(contour.list[[11]], add=TRUE, density = 20)
plot(contour.list[[14]], add=TRUE, density = 20)
plot(contour.list[[15]], add=TRUE, density = 20)
plot(contour.list[[17]], add=TRUE, density = 20)

## make veg map
plot(veg)
plot(veg[veg$Class_4 == "beach",], add=TRUE, col="khaki1")
plot(veg[veg$Class_4 == "beachgrass dune",], add=TRUE, col="khaki3")
plot(veg[veg$Class_4 == "marsh",], add=TRUE, col="aquamarine")
plot(veg[veg$Class_4 == "coastal scrub",], add=TRUE, col="khaki4")
plot(veg[veg$Class_4 == "conifer forest",], add=TRUE, col="darkolivegreen4")
plot(veg[veg$Class_4 == "fruit tree",], add=TRUE, col="coral1")
plot(veg[veg$Class_4 == "meadow",], add=TRUE, col="yellow3")
plot(veg[veg$Class_4 == "pasture",], add=TRUE, col="darkolivegreen3")
plot(veg[veg$Class_4 == "swale",], add=TRUE, col="darkseagreen3")

scalebar(1000, xy=click(), type='bar', divs=2, below = "m") ## click to place (so cool!)

plot(porc.sp[porc.sp$porc.locs.id == i,], add=TRUE, pch=16, cex=1.5, col="black")
plot(sum.sp[sum.sp$sum.locs.id == i,], add=TRUE, pch=16, cex=1.5, col="red")
